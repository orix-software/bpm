#!/usr/bin/env python3

import tarfile
import toml
import sys
import requests
import os
import gzip
import tarfile
import shutil
from datetime import datetime
import subprocess
import zipfile
from io import BytesIO
import shutil
import glob
import urllib.parse

VERSION_BPM = "2025.3.6"

build_folder = "build"
docs_folder = "docs"

main_config_path = os.path.expanduser("~/.bpm/bpm")
folder_path_md2hlp = os.path.expanduser("~/.bpm/md2hlp/")

symbs = [u'\u255a', u'\u2554', u'\u2569', u'\u2566', u'\u2560', u'\u2550', u'\u256c', u'\u2557', u'\u2551', u'\u255a', u'\u255d']

plugins_description = {
    'md2hlp': 'Build markdown into hlp file (text mode)',
    'orixsdk': 'Useful ca65 macro for Orix and reloc binary (Mandatory for Orix projects)',
    'asm_bin_tpl': 'Assembly binary template for Orix',
    'asm_rom_tpl': 'Assembly rom template for Orix',
    'github_action': 'Template for github action',
    'generatedoc': 'Tool to comment source code and generate markdown'
    }

plugins_installed = {
    'md2hlp': False,
    'orixsdk': False,
    'asm_bin_tpl': False,
    'asm_rom_tpl': False,
    'github_action': False,
    'generatedoc': False
    }

plugins_url = {
    'md2hlp': 'FIXME',
    'orixsdk': 'https://github.com/assinie/orix-sdk/archive/refs/heads/master.zip',
    'asm_bin_tpl': 'https://github.com/assinie/new-project/archive/refs/heads/main.zip',
    'asm_rom_tpl': 'https://github.com/assinie/orix-cart/archive/refs/heads/master.zip',
    'github_action': 'https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/plugins/templates/github/action/#VERSION#/main.yml',
    'generatedoc': 'https://github.com/orix-software/generatedoc/archive/refs/heads/main.zip',
}

plugins_url_version = {
    'md2hlp': 'FIXME',
    'orixsdk': 'https://raw.githubusercontent.com/assinie/orix-sdk/refs/heads/master/VERSION',
    'asm_bin_tpl': 'https://raw.githubusercontent.com/assinie/new-project/refs/heads/main/VERSION',
    'asm_rom_tpl': 'https://raw.githubusercontent.com/assinie/orix-cart/refs/heads/master/VERSION',
    'github_action': 'https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/plugins/templates/github/action/VERSION',
    'generatedoc': 'https://raw.githubusercontent.com/orix-software/generatedoc/refs/heads/main/VERSION'
}

plugins_main_property_name = {
    'md2hlp': 'default_md2hlp_version',
    'orixsdk': 'default_orixsdk_version',
    'asm_bin_tpl': 'default_asm_bin_tpl_version',
    'asm_rom_tpl': 'default_asm_rom_tpl_version',
    'github_action': 'default_github_action_version',
    'generatedoc': 'default_generatedoc_version'
}

toml_file = "bpm.tml"
user_folder = '.bpm/'


def build_without_cl65_c_files(arg_include, arg_include_asm, arg_ld_libs, file_to_compile_c, bpm_tmp_folder, name, force_build) -> int:
    generate = False

    if force_build == False:
        generate = check_src_with_target_file(file_to_compile_c,  bpm_tmp_folder + '2048.o')

    if generate == False:
        return

    arg_cc65 = ['cc65', arg_include, "--include-dir", "src/include", '-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + '2048.s',  name + ".lib"]

    try:
        resultat = subprocess.run(arg_cc65, check=True, capture_output=False, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
        exit(1)

    arg_cc65 = ['cc65', arg_include, "--include-dir", "src/include", '-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + '2304.s',  name + ".lib"]
    resultat = subprocess.run(arg_cc65, check=True, capture_output=False, text=True)
 
    arg_ca65 = ['ca65', "--include-dir", "src/include", arg_include_asm, '-ttelestrat', bpm_tmp_folder + '2048.s', "-o", bpm_tmp_folder + '2048.o' ]
    resultat = subprocess.run(arg_ca65, check=True, capture_output=False, text=True)
    arg_ca65 = ['ca65', "--include-dir", "src/include", arg_include_asm, '-ttelestrat', bpm_tmp_folder + '2304.s', "-o", bpm_tmp_folder + '2304.o' ]
    resultat = subprocess.run(arg_ca65, check=True, capture_output=False, text=True)

    ld65_command_line_list_lib = []

    if os.path.exists(name + ".lib"):
        ld65_command_line_list_lib.append(name + ".lib")

    ld65_command_line = []

    if arg_ld_libs != "":
        ld65_command_line.append(arg_ld_libs)


    ld65_command_line_list_lib.append("telestrat.lib")

    arg_ld65 = ['ld65', '-ttelestrat', bpm_tmp_folder + '2048.o', "-o", bpm_tmp_folder + '2048', '--start-addr',  '2048']


    try:
        resultat = subprocess.run(arg_ld65 + ld65_command_line + ld65_command_line_list_lib, check=True, capture_output=False, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
        exit(1)

    arg_ld65 = ['ld65', '-ttelestrat', bpm_tmp_folder + '2304.o', "-o", bpm_tmp_folder + '2304', '--start-addr',  '2304']
    resultat = subprocess.run(arg_ld65 + ld65_command_line + ld65_command_line_list_lib, check=True, capture_output=False, text=True)

def convert_binary_name_to_seven_chars(name) -> str:
    if len(name) > 7:
        print(f"Warn : name is greater than 7 chars. binary name is truncated for Orix. Binary name will be : {name[:7]}")
    return name[:7]


def decompress_and_extract(filename, dependency_name):
    """Décompresse un fichier .gz et extrait une archive .tar"""
    try:
        # Décompression du fichier .gz
        with gzip.open(filename, 'rb') as f_in:
            with open(filename[:-4] + ".tar", 'wb') as f_out:  # Enlève '.tgz'
                f_out.writelines(f_in)
        os.remove(filename)
        os.makedirs('orixlibs/' + dependency_name, exist_ok=True)
        # Extraction du fichier .tar
        with tarfile.open(filename[:-4] + ".tar", 'r') as tar:
            tar.extractall(path='orixlibs/'+ dependency_name)  # Extrait dans le répertoire orixlibs
        os.remove(filename[:-4] + ".tar")

    except Exception as e:
        print(f"Decrunching error : {e}")

def read_local_config_file():
    file_path = "bpm.tml"
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)
        # Vérifier si la section "srcfolders" existe
        if 'srcfolders' not in data:
            # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
            data['srcfolders'] = {}
            with open(file_path, 'w') as file:
                toml.dump(data, file)
        return data

    except FileNotFoundError:
        print(f"'{file_path}' not found")
    except toml.TomlDecodeError:
        print(f"Impossible to read d'{file_path}'.")


def add_dependency_to_toml(file_path, dependency_str):
    """Ajoute une nouvelle dépendance dans la section 'dependency' du fichier TOML"""
    if dependency_str == "-h":
        print("bpm add package@version")
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Si la section "dependency" n'existe pas, la créer
        if "dependencies" not in data:
            data["dependencies"] = {}

        # Séparer le nom de la dépendance et la version
        try:
            dependency_name, dependency_version = dependency_str.split("@")
            dependency_name = dependency_name.strip()
            dependency_version = dependency_version.strip().strip('"').strip("'")
        except ValueError:
            print("Format error : parameter must be : 'nom@\"version\"'.")
            return

        # Ajouter ou mettre à jour la dépendance dans le fichier TOML
        data["dependencies"][dependency_name] = dependency_version
        dependency_file = dependency_name + "lib"
        value = download_file("http://repo.orix.oric.org/dists/" + dependency_version + "/tgz/6502/" + dependency_file + ".tgz", "orixlibs/" + dependency_name + ".tgz", dependency_name)

        if value == 0:
            # Écrire les modifications dans le fichier TOML
            with open(file_path, 'w') as file:
                toml.dump(data, file)

            print(f"{dependency_name} = {dependency_version} installed")
        else:
            print(f"{dependency_name} = {dependency_version} not found")

    except FileNotFoundError:
        print(f"'{file_path}' nnot found")

    except toml.TomlDecodeError:
        print(f"Impossible to read '{file_path}'.")


def download_file(url, local_filename, dependency_name):
    """Télécharge un fichier depuis une URL"""
    os.makedirs('orixlibs', exist_ok=True)
    try:
        response = requests.get(url)
        response.raise_for_status()  # Vérifie si la requête a réussi

        with open(local_filename, 'wb') as f:
            f.write(response.content)

        decompress_and_extract(local_filename, dependency_name)
        return 0
    except requests.exceptions.RequestException as e:
        return 1


def install_dependency_from_toml(args):

    if len(args) == 3:
        if args[2] == "-h":
            print("Install all dependencies\n")
            print("Usage : bpm install\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36minstall\033[0m             Install all dependencies for this project")
            return 0

    try:
    # Lire le fichier TOML
        data = read_local_config_file()

        if "dependencies" in data:
            dependencies = data["dependencies"]
            if len(data["dependencies"]) == 0:
                print("No dependencies")
                return 0
            if len(dependencies) != 0:
                print("Dependencies:")
                for key, value in dependencies.items():
                    value_download = download_file("http://repo.orix.oric.org/dists/" + value + "/tgz/6502/" + key + ".tgz", "orixlibs/" + key + ".tgz", key)
                    if value_download == 0:
                        print(f"{key} = {value} installed")
                    else:
                        print(f"{key} = {value} not found")

    except FileNotFoundError:
        print(f"'{toml_file}' not found")

def read_dependencies_from_toml():
    try:
        # Lire le fichier TOML
        data = read_local_config_file()

        # Vérifier si la section "dependency" existe
        if "dependencies" in data:
            dependencies = data["dependencies"]
            if len(dependencies) != 0:
                print("Dependencies list :")
            else:
                print("No dependencies")
            for key, value in dependencies.items():
                print(f"{key} = {value}")
        else:
            print("'dependencies' section does not exists in bpm.tml")
    except FileNotFoundError:
        print(f"file not found : 'bpm.tml'")
    except toml.TomlDecodeError:
        print(f"Read error :  'bpm.tml'.")

def trim_after_second_dot(version):
    return '.'.join(version.split('.')[:2])

def remove_dependency_from_toml(dependency_name):
    """Supprime une dépendance de la section 'dependency' du fichier TOML"""
    try:
        data = read_local_config_file()
    except FileNotFoundError:
        print("'bpm.tml' not found")
    except toml.TomlDecodeError:
        print("Impossible to read 'bpm.tml'.")

    # Vérifier si la section "dependency" existe
    if "dependencies" in data and dependency_name in data["dependencies"]:
        del data["dependencies"][dependency_name]
        print(f"{dependency_name} uninstalled")
        if os.path.isfile("orixlibs/" + dependency_name):
            shutil.rmtree("orixlibs/" + dependency_name)
        # Écrire les modifications dans le fichier TOML
        with open(toml_file, 'w') as file:
            toml.dump(data, file)
    else:
        print(f"'{dependency_name}' dependency does not exist in bpm.tml")


def init_toml(args):
    if len(args) == 3:
        if args[2] == '-h':
            print("Init project\n")
            print("Usage : bpm init\n")
            return

    code_template = ""

    if os.path.exists(toml_file):
        print("Already initialized")
        return 0
    codetype = 'bin'
    answer = input(f"This project is :\n1) A binary program\n2) A library\n3) A rom\nanswer ?")

    if answer == '2':
        codetype = 'lib'

    if answer == '3':
        is_rom_template = input(f"Do you want to use prebuild template (n/Y)\nanswer :")
        if is_rom_template == 'Y':
            plugins_detect("no_display")
            if plugins_installed['asm_rom_tpl'] == False:
                print("Please install asm_rom_tpl plugin")
                return 1
            if plugins_installed['orixsdk'] == False:
                print("Please install orixsdk plugin")
                return 1
            code_template = "asm_rom_tpl"
        codetype = 'rom'

    current_directory = os.getcwd()
    last_directory = os.path.basename(os.path.normpath(current_directory))
    now = datetime.now()

    # Récupérer l'année courante
    current_year = now.year

    # Déterminer le trimestre actuel
    current_month = now.month
    current_trimester = (current_month - 1) // 3 + 1

    if not os.path.exists(".gitignore"):
        print("Init .gitignore")
        content = f"bpmtmp/\n{build_folder}\norixlibs\n{last_directory}.lib\n"
        with open(".gitignore", 'w') as file:
            file.write( content)

    #oricutron_replace_autoboot_run

    main_config_data = read_main_config_file()

    default_asm_bin_tpl_version = ""
    default_asm_rom_tpl_version = ""
    default_orixsdk_version = ""
    oricutron_replace_autoboot_run_for_project = ""

    if "main" in main_config_data:
        main_properties = main_config_data["main"]
        default_asm_bin_tpl_version = main_properties["default_asm_bin_tpl_version"]
        default_asm_rom_tpl_version = main_properties["default_asm_rom_tpl_version"]
        default_orixsdk_version = main_properties["default_orixsdk_version"]
        default_generatedoc_version = main_properties["default_generatedoc_version"]
        default_github_action_version = main_properties["default_github_action_version"]
        default_kernel_version = main_properties["default_kernel_version"]
        oricutron_replace_autoboot_run_for_project = main_properties["oricutron_replace_autoboot_run"]


    if not os.path.exists("bpm.tml"):
        print("Init bpm.tml")
        """Crée un fichier TOML avec des valeurs par défaut."""
        version = str(current_year) + "." + str(current_trimester)
        content = "[package]\nname = \"" + last_directory  + "\"\nversion = \"" + version + "\"\nauthors = [ \"nobody@nobody.fr\" ]\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2018\"\ncpu = \"6502\"\n"
        content = content + f"readme = \"\"\nrepository = \"\"\ndocumentation = \"\"\ndescription = \"\"\nhomepage = \"\"\nbuildfolder = \"build\"\npackagetype = \"tgz\"\ncodetype = \"{codetype}\"\ntemplatecode = \"{code_template}\"\npathsrc = \"src\"\n"
        content = content + f"oricutron_replace_autoboot_run = \"{oricutron_replace_autoboot_run_for_project}\"\n"
        content = content + f"asm_bin_tpl_version = \"{default_asm_bin_tpl_version}\"\n"
        content = content + f"asm_rom_tpl_version = \"{default_asm_rom_tpl_version}\"\n"
        content = content + f"orixsdk_version = \"{default_orixsdk_version}\"\n"
        content = content + f"default_github_action_version = \"{default_github_action_version}\"\n"
        content = content + f"default_generatedoc_version = \"{default_generatedoc_version}\"\n"
        content = content + f"orix_minimal_kernel_version = \"{default_kernel_version}\"\n"
        content = content + f"orix_run_pre_script = \"\"\n"
        content = content + f"md2hlp = \"yes\"\n"
        content = content + "\n[dependencies]\n\n[dynamiclibs]\n"
        with open("bpm.tml", 'w') as file:
            file.write(content)

    if not os.path.exists("src"):
        print("Init src folder")
        os.makedirs("src", mode=0o755, exist_ok=True)

    if not os.path.exists(f"{docs_folder}"):
        os.makedirs(f"{docs_folder}", mode=0o755, exist_ok=True)

    if codetype == 'bin':
        if not os.path.exists("src/" + last_directory + ".c"):
            print("Init " + "src/" + last_directory + ".c")
            content = "#include <stdio.h>\n\nint main() {\n    printf(\"Hello world Orix\");\n    return 0;\n}\n"
            with open("src/" + last_directory + ".c", 'w') as file:
                file.write(content)

    if codetype == 'lib':
        if not os.path.exists("src/dynamic_lib/"):
            os.makedirs("src/dynamic_lib/", mode=0o755, exist_ok=True)
            content = f"{last_directory}_mapping_dynlib:\n.asciiz \"dynlib_{last_directory}]\"\n; Include version\n.asciiz \"{version}\"\n.byt 0 ; Module version\n.byt 0 ; ROM RAM ?\n.addr {last_directory}_startup_dynlib ; {last_directory}_startup_dynlib Init will be always 0\n.proc {last_directory}_startup_dynlib\nrts\n.endproc"
            with open("src/dynamic_lib/" + last_directory + ".s", 'w') as file:
                file.write(content)

    if not os.path.exists("VERSION"):
        print("Init VERSION file")
        content = str(current_year) + "." + str(current_trimester)
        with open("VERSION", 'w') as file:
            file.write(content)

    if code_template == "asm_rom_tpl" and codetype == 'rom':
        if default_asm_rom_tpl_version == "":
            print("Fatal 'default_asm_rom_tpl_version' can be empty in ~/.bpm/bpm")
        default_orixsdk_version_truncated = trim_after_second_dot(default_orixsdk_version)
        add_dependency_to_toml(toml_file, f"orixsdk@{default_orixsdk_version_truncated}")
        folder_path_rom_bin = os.path.expanduser(f"~/.bpm/plugins/asm_rom_tpl/{default_asm_rom_tpl_version}/orix-cart-master/")
        if not os.path.exists("macros"):
            os.makedirs("macros", mode=0o755, exist_ok=True)
            shutil.copy(folder_path_rom_bin + "macros/rom_cmd.mac", "macros/rom_cmd.mac")
        shutil.copy(folder_path_rom_bin + "src/rom_cmd.s", f"src/{last_directory}.s")

    if plugins_installed['github_action'] == True:
        answer = input(f"Add github action main.yml into project: y/N ?")
        if answer == 'y':
            os.makedirs(".github/workflows/", exist_ok=True)
            home_directory = os.path.expanduser(f'~/.bpm/plugins/github_action/{default_github_action_version}/')
            shutil.copy(home_directory + "main.yml", ".github/workflows/main.yml")

    print(f"initialized")

def check_update_bpm(auto_update: bool):
    # Function which test if bpm can be updated
    answer = ""
    today = datetime.today()

    # # Formater la date au format YYYY-MM-DD
    today_format = today.strftime("%Y-%m-%d")

    main_config_data = read_main_config_file()

    if "main" in main_config_data:
        main_properties = main_config_data["main"]
        main_properties.setdefault("last_check_update", "0000-00-00")
        main_properties.setdefault("bpm_version", VERSION_BPM)

    if today_format == main_properties["last_check_update"] and auto_update == False:
        return 0

    print("Checking if an update is available (Last check : " + main_config_data["main"]["last_check_update"] + ") ...\n")
    get_version_bpm = "https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/VERSION"
    try:
        response = requests.get(get_version_bpm)
        response.raise_for_status()  # Vérifie si la requête a réussi
        online_version = response.content.decode('utf-8')

        if online_version.replace("\n", "") != main_config_data["main"]["bpm_version"]:
            current_version = main_config_data["main"]["bpm_version"]
            if auto_update == False:
                answer = input(f"A new version of bpm is available.\nCurrent version : {current_version}, Available version : \033[1;36m{online_version}\033[0m .\n if you want to install it, type 'update' or else type 'skip' : \n[update/skip] ? ")

    except requests.exceptions.RequestException as e:
        print("Can not check if a new version of 'bpm' is not available")
        return 1
    main_properties["last_check_update"] = today_format

    if answer == "update" or auto_update == True:
        get_src_bpm = "https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/src/bpm"
        try:
            response = requests.get(get_src_bpm)
            src_code = response.content.decode('utf-8')
            current_bpm_path = os.path.abspath(__file__)
            print(f"Updating to {online_version}")
            try:
                with open(current_bpm_path, 'w') as fichier:
                    fichier.write(src_code)
                main_properties["bpm_version"] = online_version
                main_properties["last_check_update"] = today_format
                print("Updated")
            # Afficher toutes les exceptions qui se produisent
            except Exception as e:
                print(f"Une erreur est survenue lors de l'écriture : {e}")

        except requests.exceptions.RequestException as e:
            print("Can not update")
            return 1

    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    try:
        # Update file
        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write( "[main]\n")
            for key, value in main_properties.items():
                fichier.write(f"{key} = \"{value}\"\n")
    except FileNotFoundError:
        print(f"'{main_config_path}' not found")

def verify_installed():
    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    if not os.path.exists(directory_path):
        # Créer le répertoire
        os.makedirs(directory_path, mode=0o755, exist_ok=True)
    if not os.path.isfile(directory_path + "/bpm"):
        # Créer le répertoire
        str_init = "[main]\noricutron_path = \"oricutron\"\noricutron_replace_autoboot_run = \"True\"\ndefault_rom_oricutron_for_code = 4\n"
        str_init = str_init + "bpm_version = \"" + VERSION_BPM + "\"\n"
        str_init = str_init + "last_check_update = \"0000-00-00\"\n"
        str_init = str_init + "default_orixsdk_version = \"\"\n"
        str_init = str_init + "default_asm_bin_tpl_version = \"\"\n"
        str_init = str_init + "default_asm_rom_tpl_version = \"\"\n"
        str_init = str_init + "default_github_action_version = \"\"\n"
        str_init = str_init + "default_kernel_version = \"2024.1\"\n"
        str_init = str_init + "default_generatedoc_version = \"\"\n"
        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write(str_init)  # Crée un fichier vide


def addsrc(args):
    if len(args) == 3:
        if args[2] == '-h':
            print("Add a source folder\n")
            print("Usage : bpm addsrc folder\n")
            return

    if len(args) == 3:
        data = read_local_config_file()
        folder = args[2]
        if 'srcfolders' in data:
            # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
            data['srcfolders'][folder] = folder
            file_path = "bpm.tml"
            with open(file_path, 'w') as file:
                toml.dump(data, file)


def search_lib(search_word: str):

    """Télécharge un fichier depuis une URL"""

    try:
        response = requests.get("http://repo.orix.oric.org/dists/official/tgz/6502/listtgz.txt")
        response.raise_for_status()  # Vérifie si la requête a réussi
        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/6502/"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory

        # Vérifier si le répertoire existe déjà
        if not os.path.exists(directory_path):
            # Créer le répertoire
            os.makedirs(directory_path, mode=0o755, exist_ok=True)

        content = ""
        for line in response.iter_lines():
            if line:  # Pour éviter les lignes vides
                content = content + line.decode('utf-8') + '\n'

        with open(directory_path + "/listtgz.txt", 'wb') as f:
            f.write(response.content)
        if search_word == "":
            content = content.replace(';lib', ' - ')  # Retirer ";lib"
            content = content.replace(';', ' ')    # Remplacer ; par des espaces
            print(content)
        else:
            with open(directory_path + "/listtgz.txt", 'r') as file:
                for line_number, line in enumerate(file, start=1):
                    # Si le mot clé est trouvé dans la ligne
                    line_split = line.split(';')
                    if line_split[2].strip() == 'lib':
                        if search_word in line_split[0]:
                            print(line_split[0] + ' ' +line_split[1])

        return 0
    except requests.exceptions.RequestException as e:
        return 1

def build_package(source_dir, output_filename, name, version):
    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 1

    build_bpm_etc_path = f"{build_folder}/etc/bpm/{name}/{version}"

    if not os.path.exists(build_bpm_etc_path):
        # Créer le répertoire
        os.makedirs(build_bpm_etc_path, mode=0o755, exist_ok=True)

    if not os.path.exists(f"{build_folder}/usr/share/{name}/{version}"):
        # Créer le répertoire
        os.makedirs(f"{build_folder}/usr/share/{name}/{version}", mode=0o755, exist_ok=True)

    if not os.path.exists(f"src/include"):
        # Créer le répertoire
        os.makedirs(f"{build_folder}/usr/include", mode=0o755, exist_ok=True)

    if not os.path.exists(f"{build_folder}/usr/include/asm"):
        # Créer le répertoire
        os.makedirs(f"{build_folder}/usr/include/asm", mode=0o755, exist_ok=True)

    if os.path.exists(f"src/include/"):
        source_dir = "src/include/"
        destination_dir = f"{build_folder}/usr/include/asm"

        # Récupère tous les fichiers .inc dans le répertoire source
        for file_path in glob.glob(os.path.join(source_dir, "*.inc")):
            # Copie chaque fichier vers le répertoire de destination
            shutil.copy(file_path, destination_dir)

        for file_path in glob.glob(os.path.join(source_dir, "*.mac")):
            # Copie chaque fichier vers le répertoire de destination
            shutil.copy(file_path, destination_dir)

    if os.path.exists(f"src/include/"):
        source_dir = "src/include/"
        destination_dir = f"{build_folder}/usr/include/"

        for root, _, files in os.walk(source_dir):
            for file in files:
                if file.endswith(".h"):  # Filtrer les fichiers .h
                    full_path = os.path.join(root, file)
                    extracted = full_path.split(source_dir, 1)[1]
                    before_last_slash, _, _ = extracted.rpartition("/")
                    if not os.path.exists(f"{destination_dir}/{before_last_slash}"):
                        # Créer le répertoire
                        os.makedirs(f"{destination_dir}/{before_last_slash}", mode=0o755, exist_ok=True)
                    print(f"{destination_dir}/{extracted}")
                    shutil.copy(full_path, f"{destination_dir}/{extracted}")

        # Récupère tous les fichiers .inc dans le répertoire source
        #for file_path in glob.glob(os.path.join(source_dir, "*.h")):
            # Copie chaque fichier vers le répertoire de destination
            # print(f"Copy {file_path} to {destination_dir}")
            # shutil.copy(file_path, destination_dir)

    if os.path.exists("README.md"):
        shutil.copy("README.md", f"{build_folder}/usr/share/{name}/{version}/README.md")

    shutil.copy("bpm.tml", f"{build_folder}/etc/bpm/{name}/{version}/bpm.tpl")
    # with tarfile.open(output_filename, "w:gz") as tar:
    #     tar.add(source_dir, arcname=os.path.basename(source_dir))
    with tarfile.open(output_filename, "w:gz") as tar:
        for item in os.listdir(f"{build_folder}"):
            item_path = os.path.join(f"{build_folder}", item)
            # Ajoute chaque fichier ou sous-répertoire sans inclure le répertoire racine `build`
            tar.add(item_path, arcname=item)


def lister_fichiers_s(repertoire):
    fichiers_s = [fichier for fichier in os.listdir(repertoire) if fichier.endswith('.s')]
    return fichiers_s


def compile(name, arg_include, folder):
    print(f"Building additionnal folder : {folder}")
    bin_ca65 = ['ca65']
    fichier_o = ""
    folder = folder + "/"
    absolute_path = os.path.abspath("")

    for fichier in os.listdir(folder):
        assembly = False

        # Vérifier si le fichier a l'extension .md
        if fichier.endswith(".s") or fichier.endswith(".c") or fichier.endswith(".asm"):
            if  os.path.exists(folder + fichier):
                assembly = True
                fichier_o = fichier.replace(".s", ".o")
            else:
                fichier_o = fichier.replace(".c", ".o")

            generate = check_src_with_target_file(folder + fichier, f"{absolute_path}/bpmtmp/" + fichier_o)

            if generate == True:
                arg_ca65 = ['-ttelestrat', folder + fichier, "-o", f"{absolute_path}/bpmtmp/" + fichier_o]

                if assembly == True and fichier != name + ".s":
                    print(f"File : {folder + fichier}")
                    resultat = subprocess.run(bin_ca65 + arg_include + arg_ca65, check=True, capture_output=False, text=True)
                    resultat = subprocess.run(['ar65', 'r', name + ".lib", f"{absolute_path}/bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)

                if assembly == False and fichier != name + ".c":
                    resultat = subprocess.run(bin_ca65 + arg_include + arg_ca65 , check=True, capture_output=False, text=True)
                    resultat = subprocess.run(['ar65', 'r', name + ".lib", f"{absolute_path}/bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
            else:
                print(f"[INFO] {fichier} not built")


def generate_lib_for_bin(name: str, arg_include, arg_include_asm: str):

    bin_ca65 = ['ca65']
    data = read_local_config_file()
    if 'srcfolders' in data:
        # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
        for key, value in data['srcfolders'].items():
            compile(name, arg_include, key)

    nb_of_files = 0
    arg_include_asm_for_ca65 = []

    if arg_include_asm != "":
        arg_include_asm_for_ca65 = [arg_include_asm]

    for fichier in os.listdir("src/"):
        assembly = False
        # Vérifier si le fichier a l'extension .md



        if fichier.endswith(".s") or fichier.endswith(".c") or fichier.endswith(".asm"):
            if  os.path.exists("src/" + name + ".s"):
                assembly = True
                fichier_o = fichier.replace(".s", ".o")
            else:
                fichier_o = fichier.replace(".c", ".o")

            arg_ca65 = ['-ttelestrat', "src/" + fichier, "-o", "bpmtmp/" + fichier_o]

            if assembly == True and fichier != name + ".s":
                try:
                    resultat = subprocess.run(bin_ca65 + arg_include_asm_for_ca65+ arg_ca65, check=True, capture_output=False, text=True)
                except subprocess.CalledProcessError as e:
                    print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                    return 1
                resultat = subprocess.run(['ar65', 'r', name + ".lib", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
                nb_of_files = nb_of_files + 1

            if assembly == False and fichier != name + ".c":
                try:
                    resultat = subprocess.run(bin_ca65 + arg_include_asm_for_ca65 + arg_ca65, check=True, capture_output=False, text=True)
                except subprocess.CalledProcessError as e:
                    print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                    return 1
                resultat = subprocess.run(['ar65', 'r', name + ".lib", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
                nb_of_files = nb_of_files + 1

    return nb_of_files

def check_src_with_target_file(filesrc: str, object_file:str) -> bool:
    generate = False

    if os.path.exists(object_file):


        time_filebuild = int(os.path.getmtime(object_file))
        time_filesrc = int(os.path.getmtime(filesrc))
        # time_filesrc_date = datetime.fromtimestamp(time_filesrc)

        # # Affichage de la date et de l'heure
        # time_filesrc_date = time_filesrc_date.strftime("%Y-%m-%d %H:%M:%S")

        # time_filebuild_date = datetime.fromtimestamp(time_filebuild)

        # # Affichage de la date et de l'heure
        # time_filebuild_date = time_filebuild_date.strftime("%Y-%m-%d %H:%M:%S")

        #print(f"compare {filesrc} {object_file} {time_filesrc_date} {time_filebuild_date}")
        if  time_filesrc > time_filebuild:
            generate = True
    else:
        generate = True
    return generate


def fix_toml_file(key, value):
    with open("bpm.tml", "r") as fichier:
        data = toml.load(fichier)

    # Vérifier et créer la propriété si nécessaire
    if "package" not in data:
        data["package"] = {}
    if key not in data["package"]:
        data["package"][key] = value

    # Sauvegarder les modifications
    with open("bpm.tml", "w") as fichier:
        toml.dump(data, fichier)

def build(args):

    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 1

    # Detect orixsdk version
    orixsdk_version = "2023.3.0"
    generate_all = False
    LD_FLAGS = []

    repertoire = 'src/'
    fichiers_s = lister_fichiers_s(repertoire)
    bpm_tmp_folder = "bpmtmp/"

    if shutil.which("cl65") is None:
        print("Error: cl65 is not installed")
        return 1

    if shutil.which("ar65") is None:
        print("Error: ar65 is not installed")
        return 1

    # Checking if .h or .inc are modifyed
    # if it's modifyed, generate all files
    val = False
    # Parcourir l'arborescence des répertoires
    for root, dirs, files in os.walk("src/include"):
        for file in files:
            # Ajouter le chemin complet du fichier à la liste
            file_path = os.path.join(root, file)
            if not os.path.exists(f"bpmtmp/{file_path}"):
                dst_dir = os.path.dirname(f"bpmtmp/{file_path}")
                os.makedirs(dst_dir, exist_ok=True)
                shutil.copy2(file_path, f"bpmtmp/{file_path}")
                generate_all = True
                break
            val = check_src_with_target_file(file_path, f"bpmtmp/{file_path}")

            if val == True:
                dst_dir = os.path.dirname(f"bpmtmp/{file_path}")
                os.makedirs(dst_dir, exist_ok=True)
                shutil.copy2(file_path, f"bpmtmp/{file_path}")
                generate_all = True
                break

    if not os.path.exists(bpm_tmp_folder):
        # Créer le répertoire
        os.makedirs(bpm_tmp_folder, mode=0o755, exist_ok=True)

    if not os.path.exists(f"{build_folder}"):
        os.makedirs(f"{build_folder}", mode=0o755, exist_ok=True)

    data = read_local_config_file()

    dynamic_lib_name_module = ""
    codetype = ""
    if "package" in data:
        codetype = data["package"]["codetype"]
        name = data["package"]["name"]
        version = data["package"]["version"]
        if "dynamic-lib-name-module" in data.get("package", {}):
            dynamic_lib_name_module = data["package"]["dynamic-lib-name-module"]


        if "package" not in data or "templatecode" not in data["package"]:
            fix_toml_file("templatecode", "")
            print("Missing 'templatecode' property in bpm.tml... Fixed")

        else:
            templatecode = data["package"]["templatecode"]

        if "asm_bin_tpl_version" in data["package"]:
            asm_bin_tpl_version = data["package"]["asm_bin_tpl_version"]
        else:
            asm_bin_tpl_version = ""

        if "asm_rom_tpl_version" in data["package"]:
            asm_rom_tpl_version = data["package"]["asm_rom_tpl_version"]
        else:
            asm_rom_tpl_version = ""

        if "orixsdk_version" in data["package"]:
            orixsdk_version  = data["package"]["orixsdk_version"]
        else:
            orixsdk_version = ""
            if codetype != "lib":
                print("Error : 'orixsdk_version' plugin is not installed available into package section of bpm.tml, it's required to produce reloc binary, set it to version installed (see bpm plugins)")
                return 1

    else:
        print("Missing package section in bpm.tml")
        exit(1)

    if not os.path.exists(f"{build_folder}/usr/share/{name}/{version}"):
        os.makedirs(f"{build_folder}/usr/share/{name}/{version}", mode=0o755, exist_ok=True)

    arg_include = ""
    arg_ld_libs = ""
    arg_include_asm = ""

    user_folder = os.path.expanduser('~')
    reloc_bin_path =  f"{user_folder}/.bpm/plugins/orixsdk/{orixsdk_version}/orix-sdk-master/bin/relocbin.py3"

    if "dependencies" in data and data["dependencies"]:
        dependencies = data["dependencies"]
        if len(dependencies) != 0:
            for key, value in dependencies.items():
                file_to_compile_c = repertoire + name + ".c"
                if os.path.exists(file_to_compile_c):
                    arg_include = arg_include + "-I"
                    arg_include = arg_include + f"orixlibs/{key}/usr/include/"
                else:
                    arg_include = arg_include + "-I"
                    arg_include = arg_include + f"orixlibs/{key}/usr/include/asm/"
                   #arg_include_asm.append("--asm-include-dir")
                    arg_include_asm = arg_include_asm + f"-I orixlibs/{key}/usr/include/asm/"
#                llo_detected = False
                #if data["dynamiclibs"] and "dynamiclibs" in data and  key in data["dynamiclibs"]:
                # if "dynamiclibs" in data:
                #     # orixlibs/curl/usr/share/curl/2025.1/
                #     if data["dynamiclibs"] and key in data["dynamiclibs"]:
                #         arg_ld_libs.append(f"orixlibs/{key}/usr/lib/{key}/{value}/llo/{key}.lib")
#                        llo_detected = True

                # if llo_detected == False:
                #     arg_ld_libs.append(f"orixlibs/{key}/usr/share/{key}/{value}/{key}.lib")


    path_etc_bpm = f"{build_folder}/etc/bpm"

    if not os.path.exists(f"{path_etc_bpm}/{version}"):
        #build/etc/bpm/file/2024.4/
        print(f"Creating {path_etc_bpm}/{name}/{version}")
        os.makedirs(f"{path_etc_bpm}/{name}/{version}", mode=0o755, exist_ok=True)

    shutil.copy("bpm.tml", f"{path_etc_bpm}/{name}/{version}/bpm.tml")


    plugins_detect("no_display")
    if plugins_installed['orixsdk']:
        home_directory = os.path.expanduser('~')
        path_orixsdk = f"{home_directory}/.bpm/plugins/orixsdk/{orixsdk_version}/orix-sdk-master/macros/"
        arg_include = arg_include + "-I"
        arg_include = arg_include + path_orixsdk

        #arg_include_asm.append("--asm-include-dir")
        arg_include_asm = arg_include_asm + f"-I {home_directory}/.bpm/plugins/orixsdk/{orixsdk_version}/orix-sdk-master/macros/"

    if codetype == "rom":
        rom_path = f"{build_folder}/usr/share/{name}/{version}/"
        if not os.path.exists(rom_path):
            os.makedirs(rom_path, mode=0o755, exist_ok=True)
        if templatecode == "asm_rom_tpl":

            if  os.path.exists(f"macros"):
                arg_include = arg_include + "-I"
                arg_include = arg_include + f"."

            home_directory = os.path.expanduser('~')
            path_orixsdk = f"{home_directory}/.bpm/plugins/asm_rom_tpl/{asm_rom_tpl_version}/orix-cart-master/cfg/rom.cfg"
            LD_FLAGS.append('-C')
            LD_FLAGS.append(path_orixsdk)

        nb__files_for_lib = generate_lib_for_bin(name, arg_include, arg_include_asm)

        nom_sans_extension = name
        file_to_compile_s = repertoire + name + ".s"
        print(f"Build : {file_to_compile_s}")
        cmd_cl65 = ['ca65']
        arg_cl65 = ['-ttelestrat', file_to_compile_s, "-o", bpm_tmp_folder + name + ".ld65", "--include-dir", "src/include"]
        resultat = subprocess.run(cmd_cl65 + arg_include + arg_cl65, check=True, capture_output=False, text=True)


        cmd_ld65 = ['ld65']
        if templatecode == "asm_rom_tpl":
            arg_ld65 = [ bpm_tmp_folder + name + ".ld65", "-o", bpm_tmp_folder + name + ".rom", "orixlibs/orixsdk/usr/lib/orix-sdk.lib"]
            resultat = subprocess.run(cmd_ld65 + LD_FLAGS + arg_ld65, check=True, capture_output=False, text=True)

        else:
            arg_ld65 = ['-tnone' , bpm_tmp_folder + name + ".ld65", "-o", bpm_tmp_folder + name + ".rom"]
            resultat = subprocess.run(cmd_ld65 + arg_ld65, check=True, capture_output=False, text=True)

        shutil.copy(bpm_tmp_folder + name + ".rom", rom_path + name + ".rom")

    if codetype == "bin":

        if not os.path.exists(f"{build_folder}/bin/"):
            os.makedirs(f"{build_folder}/bin/", mode=0o755, exist_ok=True)

        if not os.path.exists(reloc_bin_path):
            print("Error. Can not build without Orix sdk. Orix sdk not installed. orix sdk plugins is required to build binaries (see 'bpm plugins')")
            return 1

        nb__files_for_lib = generate_lib_for_bin(name, arg_include, arg_include_asm)

        nom_sans_extension = name
        file_to_compile_c = repertoire + name + ".c"
        if os.path.exists(file_to_compile_c):

            try:
                build_without_cl65_c_files(arg_include, arg_include_asm, arg_ld_libs, file_to_compile_c, bpm_tmp_folder, name, False)
                # arg_cl65 = ['-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + '2048', '--start-addr',  '2048',  "--include-dir", "src/include"]
                # arg_cl65_2304 = ['-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + '2304', '--start-addr',  '2304',  "--include-dir", "src/include"]
                # resultat = subprocess.run(bin_cl65 + arg_include_asm + arg_include + arg_cl65 + arg_ld_libs, check=True, capture_output=False, text=True)
                # resultat = subprocess.run(bin_cl65 + arg_include_asm + arg_include + arg_cl65_2304 + arg_ld_libs, check=True, capture_output=False, text=True)
                nom_sans_extension = convert_binary_name_to_seven_chars(nom_sans_extension)
                resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + nom_sans_extension, '-2' ,bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                shutil.copy(bpm_tmp_folder + nom_sans_extension, f"{build_folder}/bin/" + nom_sans_extension)
                print("Built : " + f"{build_folder}/bin/" + nom_sans_extension)
            except subprocess.CalledProcessError as e:
                print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                return 1
            return 0

        file_to_compile_s = repertoire + name + ".s"
        if os.path.exists(file_to_compile_s):

            try:
                print(f"Build : {file_to_compile_s}")
                bin_cl65 = ['cl65']
                arg_cl65 = ['-ttelestrat', file_to_compile_s, "-o", bpm_tmp_folder + '2048', '--start-addr',  '2048',  "--include-dir", "src/include", f"{name}.lib"]
                arg_cl65_2304 = ['-ttelestrat', file_to_compile_s, "-o", bpm_tmp_folder + '2304', '--start-addr',  '2304',  "--include-dir", "src/include", f"{name}.lib"]
                resultat = subprocess.run(bin_cl65 + arg_include_asm + arg_include + arg_cl65 + arg_ld_libs, check=True, capture_output=False, text=True)
                resultat = subprocess.run(bin_cl65 + arg_include_asm + arg_include + arg_cl65_2304 + arg_ld_libs, check=True, capture_output=False, text=True)
                resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + nom_sans_extension, '-2' ,bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                shutil.copy(bpm_tmp_folder + nom_sans_extension, f"{build_folder}/bin/" + nom_sans_extension)
                print("Built : " + f"{build_folder}/bin/" + nom_sans_extension)
                return 0
            except subprocess.CalledProcessError as e:
                print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")

        print(f"Main file not found : {file_to_compile_c} or {file_to_compile_s}")

    #########################################################
    # Building lib
    #########################################################

    if codetype == "lib":
        print(f"Generate {name}.lib")
        rebuild_so = False
        generate_bin_files_section = False # If we modify lib, we need to build binary files from bin section in bpm.tml

        if 'srcfolders' in data:
            # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
            for key, value in data['srcfolders'].items():
                compile(name, arg_include, key)

        # If someone erased lib; force rebuild
        if not os.path.exists(f"{name}.lib"):
            generate_all = True

        # if not os.path.exists(f"{build_folder}/usr/lib/{name}/{version}/llo/"):
        #     os.makedirs(f"{build_folder}/usr/lib/{name}/{version}/llo/", mode=0o755, exist_ok=True)

        # # Do we manage dynamic lib ?
        # if not os.path.exists(f"{build_folder}/usr/share/{name}/{version}/" + dynamic_lib_name_module):
        #     generate_all = True

        # if not os.path.exists(f"{build_folder}/usr/lib/{name}/{version}/llo/" + name + ".lib"):
        #     generate_all = True

        # if not os.path.exists(f"bpmtmp/{name}.a"):
        #     generate_all = True

        # if not os.path.exists(f"src/dynamic_lib/{name}_so.s"):
        #     generate_all = True
        #     rebuild_so = True
        #     # Create an empty file
        #     with open(f"src/dynamic_lib/{name}_so.s", 'w') as file:
        #         file.write("; stub\n")

        for fichier in fichiers_s:
            nom_sans_extension = os.path.splitext(fichier)[0]
            try:
                generate = False
                fichier_source = repertoire + fichier
                fichier_dest_o = bpm_tmp_folder + nom_sans_extension + ".o"

                generate = check_src_with_target_file(fichier_source, fichier_dest_o)
                if generate == True or generate_all == True:
                    print("Building " + repertoire + fichier)
                    bin_ca65 = ['ca65']
                    arg_ca65 = ['-ttelestrat', fichier_source, "-o", fichier_dest_o, "--include-dir", "src/include"]
                    resultat = subprocess.run(bin_ca65 + arg_include + arg_ca65, check=True, capture_output=True, text=True)
                    rebuild_so = True

            except subprocess.CalledProcessError as e:
                print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                return 1

            if generate == True or generate_all == True:
                print("Adding " + bpm_tmp_folder + nom_sans_extension + ".o to " + name + ".lib")
                resultat = subprocess.run(['ar65', 'r', name + ".lib", fichier_dest_o], check=True, capture_output=False, text=True)
                generate_bin_files_section = True
                # if fichier.startswith('_'):
                #     # Add C proto into "llo"
                #     print("[Dynamic-lib] Adding " + bpm_tmp_folder + nom_sans_extension + ".o to llo/" + name + ".lib")
                #     resultat = subprocess.run(['ar65', 'r', f"{build_folder}/usr/lib/{name}/{version}/llo/" + name + ".lib", fichier_dest_o], check=True, capture_output=False, text=True)

        ##############################################
        #  Generate lib link object (.llo)
        ##############################################
        # print("Building " + name + ".lib (for llo folder)")
        # resultat = subprocess.run(['ca65', '-ttelestrat', f"src/dynamic_lib/{name}.s", "-o", f"bpmtmp/{name}.o"], check=True, capture_output=False, text=True)
        # resultat = subprocess.run(['ar65', 'r', f"{build_folder}/usr/lib/{name}/{version}/llo/{name}.lib", f"bpmtmp/{name}.o"], check=True, capture_output=False, text=True)

        ##############################################
        #  Generate dynamic lib (.so)
        ##############################################
        # if rebuild_so == True:
        #     try:
        #         # Supprimer le fichier
        #         os.remove(f"src/dynamic_lib/{name}_so.s")
        #         with open(f"src/dynamic_lib/{name}_so.s", 'w') as file:
        #             file.write("; stub\n")

        #     except Exception as e:
        #         print(f"Error : {e}")

        #     for fichier in fichiers_s:
        #         if not fichier.startswith('_'):
        #             with open(f"src/dynamic_lib/{name}_so.s", 'a') as fichier_so:
        #                 parties = fichier.rsplit('.', 1)
        #                 proc = parties[0]
        #                 fichier_so.write(f".import {proc}\n jmp {proc}\n")

        #     resultat = subprocess.run(['cl65', '-tnone', f"src/dynamic_lib/{name}_so.s", name + ".lib" , "-o", f"bpmtmp/" + name + "_2048.lso", '--start-addr',  '2048'], check=True, capture_output=False, text=True)
        #     resultat = subprocess.run(['cl65', '-tnone', f"src/dynamic_lib/{name}_so.s", name + ".lib" , "-o", f"bpmtmp/" + name + "_2304.lso", '--start-addr',  '2304'], check=True, capture_output=False, text=True)

        #     # VErsion header 128 equal to so lib
        #     header = bytearray([0x01, 0x00, ord('o'), ord('r'), ord('i'), # Signature
        #                     128 + 0x00,                # header version : Version header b7=1 is  so (dynamic lib)
        #                     0x00,                      # CPU
        #                     0x00, 0x00,                # SIZE_BITFIELD
        #                     0x00,                      # Reserved
        #                     0x00,                      # Reserved
        #                     0x00,                      # Reserved
        #                     0x00, 0x00,                # OFFSET_BITFIELD
        #                     0x00, 0x00,                # start_adress
        #                     0x00, 0x00,                # endofmemory
        #                     0x00, 0x00,                # start_adress
        #                     ])

            # Add header for first file
            # Compute startaddr and loading address
            # byte_low = 2048 & 0xFF
            # byte_high = (2048 >> 8) & 0xFF

            # header[14] = byte_low
            # header[15] = byte_high

            # header[18] = byte_low
            # header[19] = byte_high

            # # Lire le contenu existant du fichier
            # with open(f"bpmtmp/" + name + "_2048.lso", 'rb') as fichier:
            #     contenu_existant = fichier.read()
            # val = len(contenu_existant)
            # val = val + 2048 - 1
            # # Get size
            # size_byte_low = val & 0xFF
            # size_byte_high = (val >> 8) & 0xFF
            # # Store size
            # header[16] = size_byte_low
            # header[17] = size_byte_high

            # # Écrire l'en-tête suivi du contenu existant dans le fichier
            # with open(f"bpmtmp/" + name + "_2048.so", 'wb') as fichier:
            #     fichier.write(header + contenu_existant)

            # # Manage second file

            # byte_low = 2304 & 0xFF
            # byte_high = (2304 >> 8) & 0xFF

            # header[14] = byte_low
            # header[15] = byte_high

            # header[18] = byte_low
            # header[19] = byte_high

            # # Lire le contenu existant du fichier
            # with open(f"bpmtmp/" + name + "_2304.lso", 'rb') as fichier:
            #     contenu_existant = fichier.read()
            # val = len(contenu_existant)
            # val = val + 2304 - 1
            # size_byte_low = val & 0xFF
            # size_byte_high = (val >> 8) & 0xFF

            # header[16] = size_byte_low
            # header[17] = size_byte_high

            # # Écrire l'en-tête suivi du contenu existant dans le fichier
            # with open(f"bpmtmp/" + name + "_2304.so", 'wb') as fichier:
            #     fichier.write(header + contenu_existant)

            # # Generate final .so
            # if dynamic_lib_name_module != "":
            #     resultat = subprocess.run(["python3" , reloc_bin_path, "--verbose",  "-o", f"{build_folder}/usr/share/{name}/{version}/" + dynamic_lib_name_module, '-2' ,f"bpmtmp/" + name + "_2048.so", f"bpmtmp/" + name + "_2304.so"], check=True, capture_output=False, text=True)

        path_file_lib = f"{build_folder}/usr/share/{name}/{version}"
        if not os.path.exists(path_file_lib):
            os.makedirs(path_file_lib, mode=0o755, exist_ok=True)

        if os.path.exists(name + ".lib"):
            shutil.copy(name + ".lib", f"{path_file_lib}/{name}.lib")
            print("Build completed")

        else:
            print("No build done")

    # Build all binary in [[bin]] section
    file_path = "bpm.tml"
    with open(file_path, "r") as file:
        data = toml.load(file)

    # Afficher tous les noms dans [[bin]]
    if "bin" in data:
        if not os.path.exists(f"{build_folder}/bin/"):
            os.makedirs(f"{build_folder}/bin/", mode=0o755, exist_ok=True)

        for bin_entry in data["bin"]:
            if "name" in bin_entry:
                print(f"Building binary : {bin_entry['name']}")
                binname = bin_entry["name"]
                key = f"path_{binname}"
                file_to_compile_c = bin_entry[key]
                #print(file_to_compile_c)
                if os.path.exists(file_to_compile_c):
                    try:
                        build_without_cl65_c_files(arg_include, arg_include_asm, arg_ld_libs, file_to_compile_c, bpm_tmp_folder, name, generate_bin_files_section)
                        # Perform reloc_bin
                        resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + binname, '-2' ,bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                        shutil.copy(bpm_tmp_folder + binname, f"{build_folder}/bin/" + bin_entry["name"])
                        print("Built : " + f"{build_folder}/bin/" + bin_entry["name"])
                    except subprocess.CalledProcessError as e:
                        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                    return 0
                else:
                    print(f"{file_to_compile_c} not found, can not build {binname} binary")

def usage():
    print(f"Orix build and package manager ({VERSION_BPM})\n")
    print("Documentation : https://orix-software.github.io/bpm/\n")

    print("Usage : bpm [OPTIONS] [COMMAND]\n")
    print("\033[1;32mOptions:\033[0m")
    print("    \033[1;36m-V\033[0m                     Displays version")
    print("    \033[1;36m--disable-check-update\033[0m Disables check for new version")
    print("    \033[1;36m--force-update\033[0m         Force bpm update")
    print("    \033[1;36m--replace-for-new-project\033[0m         available with --force-update option, it will install plugin for new project")


    print("")
    print("\033[1;32mCommands:\033[0m")
    print("    \033[1;36mnew\033[0m             Init a new orix package")
#    print("    \033[1;36minit\033[0m            Init an orix package in an existing directory")
    print("    \033[1;36mbuild\033[0m           Build")
    print("    \033[1;36mdoc\033[0m             Build docs")
    print("    \033[1;36mrun\033[0m             Run")
    print("    \033[1;36mlist\033[0m            List packages")
    print("    \033[1;36madd         \033[0m    Add dependencies to a manifest file")
    print("    \033[1;36mdynamiclib  \033[0m    Define a dynamic lib from dependency list")
    print("    \033[1;36mremove      \033[0m    Remove dependencies from a manifest file")
    print("    \033[1;36minstall     \033[0m    Install all dependencies from a manifest file")
    print("    \033[1;36msearch      \033[0m    Search package")
    print("    \033[1;36mpublish     \033[0m    Publish package")
    print("    \033[1;36munpublish   \033[0m    Unpublish package")
    print("    \033[1;36mplugins     \033[0m    Manage plugins")
    print("    \033[1;36mconfig      \033[0m    Manage config")
    print("    \033[1;36mpackage     \033[0m    Manage package")
    print("    \033[1;36maddsrc      \033[0m    Add src folder to build manifest file")

def plugins_detect(mode):
    force_version_for_new_project = 0

    for cle, valeur in plugins_description.items():
        if mode == "display":
            print(f"\033[1;36m{cle}\033[0m: {valeur}", end="")

        if mode == "update_and_force_new_version_for_next_project":
            force_version_for_new_project = 1

        if cle == "md2hlp":
            file_path = os.path.join(folder_path_md2hlp , "md2hlp-master/")
            if not os.path.exists(file_path):
                install_md2hlp()
                if mode == "display":
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    plugins_installed['md2hlp'] = False
            else:
                if mode == "display":
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['md2hlp'] = True

        if cle == "orixsdk":
            folder_path_orixsdk = os.path.expanduser("~/.bpm/plugins/orixsdk/")
            file_path = os.path.join(folder_path_orixsdk , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("orixsdk", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['orixsdk'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_orixsdk) if os.path.isdir(os.path.join(folder_path_orixsdk, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['orixsdk'] = True

        if cle == "asm_bin_tpl":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/asm_bin_tpl/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("asm_bin_tpl", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['asm_bin_tpl'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['asm_bin_tpl'] = True

        if cle == "asm_rom_tpl":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/asm_rom_tpl/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("asm_rom_tpl", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['asm_rom_tpl'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['asm_rom_tpl'] = True

        if cle == "github_action":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/github_action/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("github_action", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['github_action'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['github_action'] = True

        if cle == "generatedoc":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/generatedoc/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("generatedoc", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['asm_romgeneratedoc_tpl'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['generatedoc'] = True

def plugins(args):
    if len(args) == 3:
        if args[2] == "-h":
            print("Manage plugins\n")
            print("Usage : bpm plugins [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36minstall\033[0m             install plugin")
            return 0

    if len(args) == 4:
        if args[3] == "-h":
            print("Manage plugins\n")
            print("Usage : bpm plugins install [plugin_name] [--replace-for-new-project]\n")
            print("\033[1;32m--replace-for-new-project if we found a newer plugin version, update main bpm config to use this plugin version in the next projects\033[0m")
            print("\033[1;32mAvailables plugins:\033[0m")

            for cle, valeur in plugins_description.items():
                print(f"\033[1;36m{cle}\033[0m: {valeur}")
            return 0


    replace_for_new_project = 0
    if len(sys.argv) >= 3:
        if sys.argv[2] == "install":
            if len(sys.argv) == 5:
                if sys.argv[4] == "--replace-for-new-project":
                    replace_for_new_project = 1
            if len(sys.argv) >= 4:
                if sys.argv[3] == "orixsdk":
                    install_tpl_from_github('orixsdk', replace_for_new_project)
                elif sys.argv[3] == "asm_bin_tpl":
                    install_tpl_from_github('asm_bin_tpl', replace_for_new_project)
                elif sys.argv[3] == "md2hlp":
                    install_md2hlp()
                elif sys.argv[3] == "asm_rom_tpl":
                    install_tpl_from_github('asm_rom_tpl', replace_for_new_project)
                elif sys.argv[3] == "github_action":
                    install_tpl_from_github('github_action', replace_for_new_project)
                elif sys.argv[3] == "generatedoc":
                    install_tpl_from_github('generatedoc', replace_for_new_project)
                else:
                    print("Unknown plugin")
            else:
                print("Missing parameter")
        elif sys.argv[2] == "update":
            if len(sys.argv) == 5:
                if sys.argv[4] == "--replace-for-new-project":
                    replace_for_new_project = 1

            install_tpl_from_github('orixsdk', replace_for_new_project)
            install_tpl_from_github('asm_bin_tpl', replace_for_new_project)
            install_md2hlp()
            install_tpl_from_github('asm_rom_tpl', replace_for_new_project)
            install_tpl_from_github('github_action', replace_for_new_project)
            install_tpl_from_github('generatedoc', replace_for_new_project)
        else:
            print("Unknown parameter")

    if len(sys.argv) == 2:
        print("Use 'bpm plugins -h' for 'plugins' help")
        plugins_detect("display")


def modify_local_toml_key(toml_file, new_name, section, property):
    # Lire le fichier TOML
    with open(toml_file, 'r') as fichier:
        contenu = toml.load(fichier)

    # Vérifier si la section section existe et changer la valeur de 'name'
    contenu[section][property] = new_name

    # Réécrire le fichier avec la nouvelle valeur
    with open(toml_file, 'w') as fichier:
        toml.dump(contenu, fichier)

    print(f"'{property}' updated with '{new_name}'.")

def print_frame(str_to_display, sep):
    print(symbs[1], end = '')
    str_length = len(str_to_display)
    for i in range( str_length + 2):
        print(symbs[5], end = '')
    print(symbs[7])
    print(symbs[8] + ' ', end = '')
    print(str_to_display + ' ' + symbs[8])
    print(symbs[9], end = '')
    for i in range( str_length + 2):
        print(symbs[5], end = '')
    print(symbs[10])

def manage_config(args):
    valid_parameters_main = ['oricutron_path' , 'oricutron_replace_autoboot_run' , 'default_rom_oricutron_for_code']
    valid_parameters_main_desc = ['                  Set Oricutron path for main (general behavior), value must be path of Oricutron binary with filename binary in the path',
                                  '  Set False or True. False will not modify /etc/autoboot in Oricutron',
                                  '  Default rom when code type is rom : the .rom will be inserted into this slot'
                                  ]

    valid_parameters_main_verify = ['path', 'boolean', 'string']

    valid_parameters_project = ['name', 'version', 'codetype', 'oricutron_replace_autoboot_run', 'oricutron_path', 'default_rom_oricutron_for_code', 'orix_run_pre_script', 'md2hlp']
    valid_parameters_project_desc = ['                            Name of the project',
                                     '                         Version of the project',
                                     '                        Code type of the project (lib is a library, bin a command line [lib|bin])',
                                     '  Set False or True. False will not modify /etc/autoboot in Oricutron when bpm run is executed',
                                     '                  Set Oricutron path for current project',
                                     '  Default rom when code type is rom : the .rom will be inserted into this slot',
                                     '             Pre submit script : will be added before project command',
                                     '                        Activate md2hlp : enable set to yer, disabled set to no'
                                     ]

    valid_parameters_project_verify = ['string', 'string', 'values=bin,lib' ,'boolean', 'string', 'string', 'string', 'string']

    # bpm set main -h
    if len(args) == 5:
        if args[4] == '-h' and args[2] == 'set' and args[3] == 'main':
            # bpm set main -h
            print("Set main config parameters\n")
            print("Usage : bpm config set main parameter value\n")
            print("\033[1;32mParameters\033[0m")
            i = 0
            for key in valid_parameters_main:
                print(f"    \033[1;36m{key}\033[0m{valid_parameters_main_desc[i]}")
                i = i + 1
            return 0

        if args[4] == '-h' and args[2] == 'add' and args[3] == 'project':
            print("Manage config\n")
            print("Usage : bpm config add project\n")
            print("\033[1;32mCommands\033[0m")
            print("    \033[1;36mbinary\033[0m             set a binary to build")
            print("    \033[1;36mdynamic-lib\033[0m        set a dynamic lib to build (not done yet)")
            #print("binary binarybin source path")
            i = 0
            return 0

        if args[4] == '-h' and args[2] == 'set' and args[3] == 'project':
            print("Manage config\n")
            print("Usage : bpm config set project parameter value\n")
            print("\033[1;32mParameters\033[0m")
            i = 0
            for key in valid_parameters_project:
                print(f"    \033[1;36m{key}\033[0m{valid_parameters_project_desc[i]}")
                i = i + 1
            return 0


    if len(args) == 4:
        # bpm set -h
        if args[3] == '-h' and args[2] == 'set':
            print("Manage config\n")
            print("Usage : bpm config set [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mmain\033[0m             set value for 'main' config (use -h after set for 'main' help)")
            print("    \033[1;36mproject\033[0m          set value for 'project' config (use -h after set for 'project' help)")
            return 0

        # bpm add -h
        if args[3] == '-h' and args[2] == 'add':
            print("Manage config\n")
            print("Usage : bpm config set [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mproject\033[0m          set a add value for 'project'")
            return 0

    if len(args) == 3:
        if args[2] == '-h' or args[2] == 'help':
            print("Manage config\n")
            print("Usage : bpm config [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mset\033[0m             set value for main config or project config (use -h after set for 'set' help)")
            print("    \033[1;36madd\033[0m             add a binary into project file")
            return 0

        if args[2] == 'add':
            print('Missing parameter')
            print("Manage config\n")
            print("Usage : bpm config [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mset\033[0m             set value for main config or project config (use -h after set for 'set' help)")
            print("    \033[1;36madd\033[0m             add a binary into project file")
            return 0


    if len(args) == 5:

        #bpm config add project binary curl tests/curl.c arg1
        if args[4] not in valid_parameters_project and args[3] == 'project':
            print("'" + args[4] + "' is not a parameter allowed for '" + args[3] + "'")
            return 1

        if args[4] not in valid_parameters_main  and args[3] == 'main':
            print("'" + args[4] + "' is not a parameter allowed for '" + args[3] + "'")
            return 1

        if args[2] == 'set' and args[3] == 'main':
            print("Missing value for parameter '" + args[4] + "'")
            return 1

        if args[2] == 'set' and args[3] == 'project':
            print("Missing value for parameter '" + args[4] + "'")
            return 1

        if args[2] == 'add' and args[3] == 'project' and args[4] == 'dynamic-lib' and args[5] == '-h':
            print("Manage config : add a dynamic-lib to project\n")
            print("Usage : bpm config add project dynamic-lib [targetfilename]\n")
            print("targetfilename is for example 'libcurl.so'")
            return 0

    if len(args) == 6:
        if args[2] == 'add' and args[3] == 'project' and args[4] == 'dynamic-lib':
            #bpm config add project binary binarybin path
            with open("bpm.tml", "r") as file:
                data = toml.load(file)

            data["package"]["dynamic-lib-src-path-module"] = args[7]
            data["package"]["dynamic-lib-name-module"] = args[8]

            # Enregistrer les modifications dans le fichier
            with open("bpm.tml", "w") as file:
                toml.dump(data, file)
            print("dynamic-lib added")
            return 0


    if len(args) > 6:
        # bpm config add project binary curl tests/curl.c arg1
        if args[2] == 'add' and args[3] == 'project' and args[4] == 'binary':
            #bpm config add project binary binarybin path
            with open("bpm.tml", "r") as file:
                data = toml.load(file)
            # Ajouter la section [[bin]] avec les valeurs souhaitées
            if len(args) == 8:
                bin_section = {"name": args[5], "path_"+ args[5]: args[6], "extra_args_"+ args[5]: args[7]}
            else:
                bin_section = {"name": args[5], "path_"+ args[5]: args[6]}

            data["bin"] = []
            data["bin"].append(bin_section)

            # Enregistrer les modifications dans le fichier
            with open("bpm.tml", "w") as file:
                toml.dump(data, file)
            print("Binary added")
            return 0

    if len(args) == 6:

        if args[2] == 'add' and args[3] == 'project' and args[4] == 'binary' and args[5] == '-h':
            print("Manage config : add a binary to project\n")
            print("Usage : bpm config add project binary [name of the binary] [path_of_the_source_code]\n")
            return 0

        if args[2] == 'set' and args[3] == 'main':
            if args[4] in valid_parameters_main:
                verify_position = valid_parameters_main.index(args[4])
                if valid_parameters_main_verify[verify_position] == 'boolean':
                    if args[5] != 'True' and args[5] != 'False':
                        print(f"Error {args[4]} requires True or False")
                        return

                home_directory = os.path.expanduser('~')

                new_directory = f"{user_folder}/bpm"
                # Chemin complet du nouveau répertoire
                directory_path = home_directory + "/" + new_directory

                print("Updating 'main' config value ...")
                modify_local_toml_key(directory_path, args[5], 'main', args[4])
                return
            else:
                print(f"Unknown key '{args[4]}' for 'main' config")
                return

        if args[2] == 'set' and args[3] == 'project':
            verify_position = valid_parameters_project.index(args[4])
            if args[4] in valid_parameters_project:
                if valid_parameters_project_verify[verify_position] == 'boolean':
                    if args[5] != 'True' and args[5] != 'False':
                        print(f"Error {args[4]} requires True or False")
                        return
                print("Updating 'project' config value ...")
                modify_local_toml_key('bpm.tml', args[5], 'package', args[4])
                return
            else:
                print(f"Unknown key '{args[4]}' for 'project' config")
                return

    if len(sys.argv) == 2:
        if not os.path.exists("bpm.tml"):
            print("bpm.tml does not exist. Initialize first")
            return 1

        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/bpm"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory
        print_frame("Main config", "")

        try:
            with open(directory_path, 'r') as fichier:
                contenu = fichier.read()
                print(contenu)
        except FileNotFoundError:
            print(f"Le fichier '{directory_path}' n'a pas été trouvé.")
        except Exception as e:
            print(f"Une erreur est survenue : {e}")

    print_frame("Project config", "")
    with open(toml_file, 'r') as file:
        data = toml.load(file)

    if "package" in data:
        package = data["package"]
        for key, value in package.items():
            print(f"{key}={value}")


def publish(filename: str, args, mode):
    repo = "alpha"
    if len(args) == 3:
        if mode == "publish":
            if args[2] == "-h":
                print("Manage publish\n")
                print("Usage : bpm publish [OPTIONS]\n")
                print("\033[1;32mOptions:\033[0m")
                print("    \033[1;36m--alpha\033[0m          Publish in alpha repo (default)")
                print("    \033[1;36m--official\033[0m       Publish in official repo")
                print("    \033[1;36m--personnal\033[0m      Publish in personnal (stored in login associated to the the BPM_PUBLISH_KEY) repo")
                return 0
        elif mode == "unpublish":
            if args[2] == "-h":
                print("Unpublish a pacjage\n")
                print("Usage : bpm unpublish [OPTIONS]\n")
                print("\033[1;32mOptions:\033[0m")
                print("    \033[1;36m--alpha\033[0m          Unpublish from alpha repo (default)")
                print("    \033[1;36m--official\033[0m       Unpublish from official repo")
                print("    \033[1;36m--personnal\033[0m      Unpublish from personnal (stored in login associated to the the BPM_PUBLISH_KEY) repo")
                return 0
        if args[2] == "--alpha":
            repo = "alpha"
        elif args[2] == "--official":
            repo = "official"
        elif args[2] == "--personnal":
            repo = "personnal"
        else:
            print("Unknown parameter")
            return 1

    conf = read_local_config_file()
    publish_key = os.getenv('BPM_PUBLISH_KEY')
    name = conf["package"]["name"]
    version = conf["package"]["version"]
    cpu = conf["package"]["cpu"]
    codetype = conf["package"]["codetype"]
    description = conf["package"]["description"]
    documentation = conf["package"]["documentation"]
    documentation = urllib.parse.quote_plus(documentation)

    if publish_key is None:
        print("BPM_PUBLISH_KEY is not defined in order to publish on repo.orix.oric.org. To get one, send an email to jede[at]oric[dot]org")
        return 1

    if mode == "publish":
        action = "add"

    if mode == "unpublish":
        action = "delete"

    if mode == "publish":
        encoded_description = urllib.parse.quote(description)
        url = f"http://api.orix.oric.org/v1/libtgz?cpu={cpu}&repo={repo}&version={version}&name={name}&codetype={codetype}&action={action}&description={encoded_description}&documentation={documentation}&key=" + publish_key
        with open(filename, 'rb') as fichier:
            fichiers = {filename: fichier}  # Préparer le fichier pour l'envoi

            # Effectuer la requête POST
            response = requests.post(url, files=fichiers)
            print(response.content)
            # Vérifier si la requête a réussi
            if response.status_code == 200:
                print("Success!")
                return 0
            else:
                print(f"Failed. Error code : {response.status_code}")
                print(f"API response: {response.text}")
                return 1

    if mode == "unpublish":
        # Effectuer la requête POST
        url = f"http://api.orix.oric.org/v1/libtgz?cpu={cpu}&repo={repo}&version={version}&name={name}&action={action}&codetype={codetype}&key=" + publish_key
        response = requests.post(url)
        print(response.content)
        # Vérifier si la requête a réussi
        if response.status_code == 200:
            print("Success!")
            return 0
        else:
            print(f"Failed. Error code : {response.status_code}")
            print(f"API response: {response.text}")
            return 1

def install_tpl_from_github(plugin_name, replace_for_next_version):
    # Chatgpt:
    # Si le folder ~/.bpm/tpl/asm_bin_tpl/ n'existe pas, telecharge https://github.com/assinie/new-project/archive/refs/heads/main.zip, dezippe le dans ~/.bpm/tpl/
    # Définir le chemin du dossier asm_bin_tpl
    answer = ""
    folder_path = os.path.expanduser(f"~/.bpm/plugins/{plugin_name}/")
    # Get version
    response = requests.get(plugins_url_version[plugin_name])

    if response.status_code == 200:
        plugin_version = response.text
        plugin_version = plugin_version.replace("\n", "")

    else:
        print(f"Impossible to download VERSION definition : {plugins_url_version[plugin_name]} {response.status_code}")
        return 1

    print(f"\nInstalling plugin : {plugin_name} Version : {plugin_version}")

    path_plugin = folder_path + plugin_version

    # Vérifier si le dossier existe
    if not os.path.exists(path_plugin):

        # Créer le dossier parent ~/.bpm/{plugin_name}/{plugin_version} s'il n'existe pas
        parent_folder = os.path.dirname(path_plugin + "/" + plugin_version)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        # Télécharger l'archive depuis GitHub

        url_for_plugin = plugins_url[plugin_name].replace("#VERSION#", plugin_version)
        response = requests.get(url_for_plugin)


        # Vérifier si le téléchargement est réussi
        if response.status_code == 200:
            # Décompresser l'archive
            if url_for_plugin.endswith(".zip"):
                with zipfile.ZipFile(BytesIO(response.content)) as z:
                    z.extractall(parent_folder)  # Décompresser dans ~/.bpm/tpl/
            else:
                destfile = parent_folder + "/" + url_for_plugin.split("/")[-1]
                with open(destfile, "wb") as file:
                    file.write(response.content)

            if replace_for_next_version == 0:
                answer = input(f"Set this plugin version '{plugin_version}' for next projects (this plugin version will be set when 'bpm new' is sent)? (N/y)")

            if answer == 'y' or answer == 'Y' or replace_for_next_version == 1:
                main_config_path = os.path.expanduser(f"~/.bpm/bpm")
                modify_local_toml_key(main_config_path, plugin_version, 'main', plugins_main_property_name[plugin_name])
            print("Installed")

        else:
            print("Erreur lors du téléchargement. Code de statut:", response.status_code)
            return 1
    else:
        print(f"Already installed : {plugin_name}")


def install_md2hlp():
    # Chatgpt:
    # Si le folder ~/.bpm/md2hlp/ n'existe pas, telecharge https://github.com/assinie/md2hlp/archive/refs/heads/master.zip, dezippe le dans ~/.bpm/md2hlp/
    print("Installing md2hlp")

    # Créer le dossier s'il n'existe pas
    if not os.path.exists(folder_path_md2hlp):
        os.makedirs(folder_path_md2hlp)

    # Télécharger l'archive depuis GitHub
    url = "https://github.com/assinie/md2hlp/archive/refs/heads/master.zip"
    response = requests.get(url)

    # Vérifier si le téléchargement est réussi
    if response.status_code == 200:

        # Décompresser l'archive
        with zipfile.ZipFile(BytesIO(response.content)) as z:
            z.extractall(folder_path_md2hlp )

        print("md2hlp installed")
    else:
        print("Download error. Error code :", response.status_code)

def build_doc(toml_file):
    md2hlp_generate = False
    generatedoc_generate = False

    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 0

    data = read_local_config_file()

    # Test md2hlp
    # Chatgpt :
    plugins_detect("detect")
    if not plugins_installed['md2hlp']:
        install_md2hlp()

    if not plugins_installed['generatedoc']:
        install_tpl_from_github("generatedoc", 0)
    plugins_detect("detect")

    if not plugins_installed['generatedoc']:
        print('generatedoc not detected, skipping generatedoc generation')
    else:
        generatedoc_generate = True

    if not plugins_installed['md2hlp']:
        print('md2hlp not detected, skipping md2hlp generation')
    else:
        md2hlp_generate = True

    if "package" in data:
        package = data["package"]
        version =  data["package"]["version"]

        if "md2hlp" in package:
            if package["md2hlp"] == 'no':
                md2hlp_generate = False
            else:
                md2hlp_generate = True

        if "docsfolder" in package:
            docs_folder = package["docsfolder"]

        if "default_generatedoc_version" in package:
            default_generatedoc_version = package["default_generatedoc_version"]
        else:
            main_config_data = read_main_config_file()
            if "main" in main_config_data:
                if "default_generatedoc_version" in main_config_data["main"]:
                    default_generatedoc_version = main_config_data["main"]["default_generatedoc_version"]
                else:
                    generatedoc_generate = False
                    print("Generate doc default version not found in main config.")
            else:
                generatedoc_generate = False
                print("Missing main section in main config.")
    else:
        print("Error missing package section in bpm.tml")

    if md2hlp_generate:
        if not os.path.exists("src/md2hlp.cfg"):
            home_directory = os.path.expanduser('~')
            directory_path = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.cfg"
            shutil.copy(directory_path, f"{docs_folder}/")

        if not os.path.exists(f"{build_folder}/usr/share/man/"):
            os.makedirs(f"{build_folder}/usr/share/man/", exist_ok=True)

        home_directory = os.path.expanduser('~')
        md2hlp_cmd = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.py3"

        for fichier in os.listdir(f"{docs_folder}"):
            # Vérifier si le fichier a l'extension .md
            generate = False
            if fichier.endswith(".md"):
                my_file = fichier.replace('.md', ".hlp")
                generate = check_src_with_target_file(f"{docs_folder}/{fichier}", f"{build_folder}/usr/share/man/{my_file}")
                if generate == True and os.path.getsize(f"{docs_folder}{fichier}") != 0:
                    print(f"[md2hlp] Generating {fichier} to {build_folder}/usr/share/man/{my_file}")
                    resultat = subprocess.run(['python3', md2hlp_cmd, '--config', f'{docs_folder}/md2hlp.cfg',  '--file', f"{docs_folder}/{fichier}", "--output", f"{build_folder}/usr/share/man/{my_file}"] , check=True, capture_output=False, text=True)

    if generatedoc_generate:
        # if not os.path.exists("src/md2hlp.cfg"):
        #     home_directory = os.path.expanduser('~')
        #     directory_path = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.cfg"
        #     shutil.copy(directory_path, "docs/")

        # if not os.path.exists("build/usr/share/man/"):
        #     os.makedirs("build/usr/share/man/", exist_ok=True)

        home_directory = os.path.expanduser('~')
        generatedoc_cmd_assembly = home_directory + f"/.bpm/plugins/generatedoc/{default_generatedoc_version}/generatedoc-main/src/ca65todoc.py"
        generatedoc_cmd_c = home_directory + f"/.bpm/plugins/generatedoc/{default_generatedoc_version}/generatedoc-main/src/ca65todoc_c_proto.py"

        if not os.path.exists(f"{docs_folder}/{version}/"):
            os.makedirs(f"{docs_folder}/{version}/")

        for fichier in os.listdir("src"):
            # Vérifier si le fichier a l'extension .md
            generate = False
            if fichier.endswith(".s"):
                my_file = fichier.replace('.s', ".md")
                generate = check_src_with_target_file(f"src/{fichier}", f"{docs_folder}/{version}/{my_file}")
                if generate == True and os.path.getsize(f"src/{fichier}") != 0:
                    print(f"[ca65tomd] Generating doc for src/{fichier} to {docs_folder}/{version}/{my_file}")
                    #ca65todoc_c_proto.py
                    if fichier.startswith('_'):
                        resultat = subprocess.run(['python3', generatedoc_cmd_c, f"src/{fichier}", f"{docs_folder}/{version}/{my_file}"], check=True, capture_output=True, text=True)
                    else:
                        resultat = subprocess.run(['python3', generatedoc_cmd_assembly, f"src/{fichier}", f"{docs_folder}/{version}/{my_file}"], check=True, capture_output=True, text=True)


def update_package(args):
    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 1

    folder = "orixlibs"

    if not os.path.exists(folder):
        os.makedirs(folder)

    data = read_local_config_file()
    if "dependencies" in data and len(data["dependencies"]) != 0:
        dependencies = data["dependencies"]
        for key, value in dependencies.items():
            print(f"Updating : {key}")
            remove_dependency_from_toml(key)
            add_dependency_to_toml(toml_file, f"{key}@{value}")


def read_main_config_file():
    # Returns array of the content of main config file
    try:
        # Lire le fichier TOML
        with open(main_config_path, 'r') as file:
            data = toml.load(file)
        return data
    except FileNotFoundError:
        print(f"'{toml_file}' not found")

def execute_binaries(path_oricutron, orix_run_pre_script, oricutron_replace_autoboot_run, binary_to_launch, bin_oricutron, current_pwd, bpm_tmp_folder, names, extra_arg):
    # names : all binaries to name to build
    autoboot_oricutron_folder = "/sdcard/ETC/AUTOBOOT"
    full_autoboot_oricutron_folder = path_oricutron + autoboot_oricutron_folder
    orix_run_pre_script_content = ""

    if orix_run_pre_script != "":
        try:
            # Ouverture et lecture du fichier
            with open(orix_run_pre_script, 'r') as fichier:
                orix_run_pre_script_content = fichier.read()
        except FileNotFoundError:
            print(f"File not found '{orix_run_pre_script}' ('orix_run_pre_script' defines in project config file)")
            exit(1)
        except Exception as e:
            print(f"error : {e}")

    extra_arg_param = ""
    if oricutron_replace_autoboot_run == "True":
        if binary_to_launch == "":
            all_names = ""
            for name in names:
                if extra_arg[name] != "":
                    extra_arg_param = extra_arg[name]

                name_7 = convert_binary_name_to_seven_chars(name)
                all_names = all_names + name_7 + "\n"

            content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{all_names}{extra_arg_param}\n"
        else:
            name_7 = convert_binary_name_to_seven_chars(binary_to_launch)
            content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{name_7}\n"

        if os.path.exists(full_autoboot_oricutron_folder):
            shutil.copy(full_autoboot_oricutron_folder, bpm_tmp_folder + "AUTOBOOT_OLD")
            old_autoboot_exists = True
        with open(full_autoboot_oricutron_folder, 'w') as file:
            file.write(content)
    os.chdir(path_oricutron)
    try:
        print(f"Execute : {bin_oricutron}")
        subprocess.run([bin_oricutron], check=True)
    except Exception as e:
        print(f"Error : {e}")
    finally:
        # Revenir au répertoire initial
        os.chdir(current_pwd)
        if oricutron_replace_autoboot_run == "True" and old_autoboot_exists:
            print("Restore old autoboot")
            shutil.copy(bpm_tmp_folder + "AUTOBOOT_OLD", full_autoboot_oricutron_folder)


def run_bin(args):
    bpm_tmp_folder = "bpmtmp/"
    old_autoboot_exists = False
    current_pwd = os.getcwd()
    binary_to_launch = ""
    orix_run_pre_script = ""
    extra_arg = ""

    if len(sys.argv) > 2:
        if sys.argv[2] == '--':

            for i in range(3, len(sys.argv)):
                extra_arg =  extra_arg + " " + sys.argv[i]
            print(f"Extra arg : {extra_arg}")

        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("Run project\n")
                print("Usage : bpm run [-- arg1] [--bin MYBINARY]\n")
                return

            if sys.argv[2] == '--bin':
                print("Missing binary")
                print("Run project\n")
                print("Usage : bpm run [--bin MYBINARY]\n")
                return


        if len(sys.argv) == 4:
            if sys.argv[2] == '--bin':
                binary_to_launch = sys.argv[3]

    try:
        # Lire le fichier TOML
        with open(main_config_path, 'r') as file:
            data = toml.load(file)

        if "main" in data:
            path_oricutron = data["main"]["oricutron_path"]
            if path_oricutron == "":
                print("oricutron_path is empty, set it with 'bpm config set oricutron_path *Yourpath*'")
                return
            if not os.path.isfile(path_oricutron):
                print(f"Error : in 'oricutron_path' parameter, {path_oricutron} is not a file. Set Oricutron path with 'bpm config set main oricutron_path *Yourpath*'")
                return

            default_rom_oricutron_for_code = 4

            if "default_rom_oricutron_for_code" in data["main"]:
                if data["main"]["default_rom_oricutron_for_code"] != "":
                    default_rom_oricutron_for_code = int(data["main"]["default_rom_oricutron_for_code"])

    except FileNotFoundError:
        print(f"'{main_config_path}' not found")

    data = read_local_config_file()

    oricutron_replace_autoboot_run = "True"
    if "package" in data:
        name =  data["package"]["name"]
        codetype =  data["package"]["codetype"]
        version =  data["package"]["version"]
        if "default_rom_oricutron_for_code" in data["package"]:
            if data["package"]["default_rom_oricutron_for_code"] != "":
                default_rom_oricutron_for_code = int(data["package"]["default_rom_oricutron_for_code"])

        if "orix_run_pre_script" in data["package"]:
            orix_run_pre_script = data["package"]["orix_run_pre_script"]

        if "oricutron_path" in data["package"]:
            if data["package"]["oricutron_path"] != "":
                path_oricutron_project = data["package"]["oricutron_path"]
                if not os.path.isfile(path_oricutron_project):
                    print(f"Error : in 'oricutron_path' parameter, {path_oricutron_project} is not a file. Set Oricutron path with 'bpm config set project oricutron_path *Yourpath*'")
                    return
                path_oricutron = path_oricutron_project
            oricutron_replace_autoboot_run =  data["package"]["oricutron_replace_autoboot_run"]
    else:
        print("Error 'bpm.tml' does not contains 'package' section")
        return 1

    bin_oricutron = path_oricutron
    path_oricutron = os.path.dirname(path_oricutron)


    #shutil.copy("build/bin/" + name, path_oricutron + "/sdcard/BIN/" + name.upper())
    if os.path.exists(f"{build_folder}/bin"):
        build_bin = f"{build_folder}/bin/"
        dest_oricutron_bin = path_oricutron + "/sdcard/BIN/"
        # Copier tout le contenu de {build_folder}/bin
        for item in os.listdir(build_bin):
            source_path = os.path.join(build_bin, item)
            destination_path = os.path.join(dest_oricutron_bin, item.lower())

            if os.path.isdir(source_path):
                shutil.copytree(source_path, destination_path, dirs_exist_ok=True)
            else:
                shutil.copy2(source_path, destination_path)
                print("Copy ...")

    if codetype == "rom":
        path_to_oricutron_rom = f"sdcard/USR/SHARE/" + name.upper() + "/" + version.upper() + "/"

        if not os.path.exists(path_oricutron + '/' + path_to_oricutron_rom):
            os.makedirs(path_oricutron + '/' + path_to_oricutron_rom, exist_ok=True)

        shutil.copy(f"{build_folder}/usr/share/{name}/{version}/{name}.rom", path_oricutron + '/' + path_to_oricutron_rom)


        path_twilighte_board_cfg_plugin = path_oricutron + "/plugins/twilighte_board/twilighte.cfg"
        with open(path_twilighte_board_cfg_plugin, "r") as file:
            lines = file.readlines()

        if default_rom_oricutron_for_code == "":
            default_rom_oricutron_for_code = 4

        if default_rom_oricutron_for_code < 10:
            default_rom_oricutron_for_code_str = f"rom0{default_rom_oricutron_for_code}"
        else:
            default_rom_oricutron_for_code_str = f"rom{default_rom_oricutron_for_code}"

        if default_rom_oricutron_for_code < 42 and default_rom_oricutron_for_code > 31:
            default_rom_oricutron_for_code_str = f"ram0{default_rom_oricutron_for_code}"

        if default_rom_oricutron_for_code > 42:
            default_rom_oricutron_for_code_str = f"ram{default_rom_oricutron_for_code}"


        twilbank_found = False
        with open(path_twilighte_board_cfg_plugin, "w") as file:
            for line in lines:
                if f"twilbank{default_rom_oricutron_for_code_str}" in line:
                    #print(f"Writing !!!twilbankrom{default_rom_oricutron_for_code_str}")
                    twilbank_found = True
                    file.write(f"twilbank{default_rom_oricutron_for_code_str}='{path_to_oricutron_rom}/{name}'\n")
                    break
                else:
                    file.write(line)

            if not twilbank_found:
                    file.write(f"twilbank{default_rom_oricutron_for_code_str}='{path_to_oricutron_rom}/{name}'\n")

    # if codetype == "bin":
    #     print(path_oricutron + '/sdcard/bin')
    #     shutil.copy(f"build/bin/{name}", path_oricutron + f'/sdcard/bin/{name}')

    # Generate submit file
    if codetype == "bin":
        names = { f"{name}" }
        extra_args = {}
        extra_args[name] = ""
        execute_binaries(path_oricutron, orix_run_pre_script, oricutron_replace_autoboot_run, binary_to_launch, bin_oricutron, current_pwd, bpm_tmp_folder, names, extra_args)
 
        # autoboot_oricutron_folder = "/sdcard/ETC/AUTOBOOT"
        # full_autoboot_oricutron_folder = path_oricutron + autoboot_oricutron_folder

        # orix_run_pre_script_content = ""
        # if orix_run_pre_script != "":
        #     try:

        #         # Ouverture et lecture du fichier
        #         with open(orix_run_pre_script, 'r') as fichier:
        #             orix_run_pre_script_content = fichier.read()

        #     except FileNotFoundError:
        #         print(f"File not found '{orix_run_pre_script}' ('orix_run_pre_script' defines in project config file)")
        #         exit(1)
        #     except Exception as e:
        #         print(f"error : {e}")

        # if oricutron_replace_autoboot_run == "True":
        #     if binary_to_launch == "":
        #         name_7 = convert_binary_name_to_seven_chars(name)
        #         content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{name_7}{extra_arg}\n"
        #     else:
        #         name_7 = convert_binary_name_to_seven_chars(binary_to_launch)
        #         content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{name_7}\n"

        #     # if not os.path.exists(path_oricutron + "/sdcard/ETC/"):
        #     #     os.makedirs(path_oricutron + "/sdcard/ETC/", exist_ok=True)
        #     #     open(full_autoboot_oricutron_folder, 'a').close()

        #     if os.path.exists(full_autoboot_oricutron_folder):
        #         shutil.copy(full_autoboot_oricutron_folder, bpm_tmp_folder + "AUTOBOOT_OLD")
        #         old_autoboot_exists = True

        #     with open(full_autoboot_oricutron_folder, 'w') as file:
        #         file.write(content)

        # os.chdir(path_oricutron)
        # try:
        #     print(f"Execute : {bin_oricutron}")
        #     subprocess.run([bin_oricutron], check=True)

        # except Exception as e:
        #     print(f"Error : {e}")

        # finally:
        #     # Revenir au répertoire initial
        #     os.chdir(current_pwd)
        #     if oricutron_replace_autoboot_run == "True" and old_autoboot_exists:
        #         print("Restore old autoboot")
        #         shutil.copy(bpm_tmp_folder + "AUTOBOOT_OLD", full_autoboot_oricutron_folder)

    if codetype == 'lib':
    # Afficher tous les noms dans [[bin]]
        print("################## bla")
        if "bin" in data:
            if not os.path.exists(f"{build_folder}/bin/"):
                os.makedirs(f"{build_folder}/bin/", mode=0o755, exist_ok=True)
            names = {}
            extra_args = {}
            for bin_entry in data["bin"]:
                if "name" in bin_entry:
                    binname = bin_entry["name"]
                    key = f"path_{binname}"
                    file_to_compile_c = bin_entry[key]
                    names[bin_entry["name"]] = file_to_compile_c
                    key = f"extra_args_{name}"
                    if key in bin_entry:
                        extra_args[binname] = bin_entry[key]
                    else:
                        extra_args[binname] = ""
            execute_binaries(path_oricutron, orix_run_pre_script, oricutron_replace_autoboot_run, binary_to_launch, bin_oricutron, current_pwd, bpm_tmp_folder, names, extra_args)
        else:
            print("lib is not managed yet with 'bpm run' command")

def dynamic_lib(args):

    if len(sys.argv) == 2:
        print("add        add dynamic lib, lib requires to be in dependencies")
        print("remove     Remove dynamic lib, (revert into static lib)")

    if (len(sys.argv) == 3 and args[2] == 'add') or (len(sys.argv) == 3 and args[2] == 'remove'):
        print("missing arg for add or remove")

    if (len(sys.argv) == 4 and args[2] == 'add') or (len(sys.argv) == 4 and args[2] == 'remove'):
        data = read_local_config_file()

        if "dependencies" in data:
            for chaine in data["dependencies"]:
                if args[3] in chaine:
                    print("Found")
                    if args[3] not in data["dynamiclibs"]:
                        data["dynamiclibs"][args[3]] = ""
                        with open("bpm.tml", 'w') as file:
                            toml.dump(data, file)
                    else:
                        print(f"{args[3]} already in dynamiclibs")
                    return 0
            print(f"Error : dependency '{args[3]}' not found in dependencies")
        else:
            print("'dependencies' section not found in bpm.tml")


def main():
    verify_installed()

    if len(sys.argv) == 1:
        check_update_bpm(False)
        plugins_detect("not_display")
        usage()
        sys.exit(1)

    valid_commands = ['build', 'config', 'd', 'doc', 'dynamiclib', 'plugins', 'list', 'add', 'addsrc', 'run', 'remove', 'new', 'install', '-V', 'search', '--force-update', '--disable-check-update', 'package', 'publish', '--replace-for-new-project', 'run', 'update','unpublish']

    if sys.argv[1] not in valid_commands:
        usage()
        sys.exit(1)

    action = sys.argv[1]

    if action == '--force-update':
        sys.argv.remove("--force-update")
        if len(sys.argv) != 1:
            action = sys.argv[1]
        check_update_bpm(True)
        update_and_force_new_version_for_next_project = 0
        for arg in sys.argv:
            if arg == "--replace-for-new-project":
                update_and_force_new_version_for_next_project = 1
        #update_and_force_new_version_for_next_project
        #--replace-for-new-project
        if update_and_force_new_version_for_next_project == 1:
            plugins_detect("update_and_force_new_version_for_next_project")
        else:
            plugins_detect("not_display")

    elif action == '--disable-check-update':
        sys.argv.remove("--disable-check-update")
        action = sys.argv[1]
    else:
        check_update_bpm(False)
        action = sys.argv[1]
        plugins_detect("not_display")

    if action == 'run':
        ret = build(sys.argv)
        if ret == 0:
            run_bin(sys.argv)
        else:
            print("Error during build, cannot run")
            return 1
    elif action == '-V':
        print(VERSION_BPM)
    elif action == 'doc' or action == 'd':
        build_doc(toml_file)
    elif action == 'list':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        read_dependencies_from_toml()
    elif action == 'add':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        if  len(sys.argv) == 3:
            dependency_str = sys.argv[2]
            add_dependency_to_toml(toml_file, dependency_str)
        else:
            print("Missing parameter")
            print("Type 'bpm add --help'")
    elif action == 'dynamiclib':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        dynamic_lib(sys.argv)
    elif action == 'remove':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        if len(sys.argv) == 3:
            dependency_name = sys.argv[2]
            remove_dependency_from_toml(dependency_name)
        else:
            print("remove needs an argument")
    elif action == 'install':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        install_dependency_from_toml(sys.argv)
    elif action == 'addsrc':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        addsrc(sys.argv)

    elif action == 'search':
        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("Search lib\n")
                print("Usage : bpm search [libname]\n")
                return
        to_find = ""
        if len(sys.argv) == 3:
            to_find = sys.argv[2]
        search_lib(to_find)

    elif action == 'update':
        update_package(sys.argv)

    elif action == 'package':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        data = read_local_config_file()
        build_doc(toml_file)
        build(sys.argv)
        if data["package"]["codetype"] == "lib":
            package_name = data["package"]["name"] + "lib.tgz"
        else:
            package_name = data["package"]["name"] + ".tgz"
        build_package("build", package_name , data["package"]["name"], data["package"]["version"])
    elif action == 'new':
        init_toml(sys.argv)
    elif action == 'plugins':
        plugins(sys.argv)
    elif action == 'config':
        manage_config(sys.argv)
    elif action == 'build':
        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("bpm build")
                return 0
        build(sys.argv)
    elif action == 'init':
        if not os.path.exists(toml_file):
            init_toml(sys.argv)
        else:
            print("Already initialized")
    elif action == 'publish':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        tgz_to_upload = ""
        if len(sys.argv) == 4:
            if sys.argv[2] == 'pathtgz':
                tgz_to_upload = sys.argv[3]

        data = read_local_config_file()

        if tgz_to_upload == "":
            build_doc(toml_file)
            build(sys.argv)

        if data["package"]["codetype"] == "lib":
            package_name = data["package"]["name"] + "lib.tgz"
        else:
            package_name = data["package"]["name"] + ".tgz"

        if tgz_to_upload == "":
            build_package("build", package_name, data["package"]["name"], data["package"]["version"])

        return publish(package_name, sys.argv, "publish")
    elif action == 'unpublish':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        data = read_local_config_file()
        if data["package"]["codetype"] == "lib":
            package_name = data["package"]["name"] + "lib.tgz"
        else:
            package_name = data["package"]["name"] + ".tgz"
        return publish(package_name, sys.argv, "unpublish")
    # Lire et afficher les dépendances


if __name__ == "__main__":
    main()
