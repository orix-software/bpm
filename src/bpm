#!/usr/bin/env python3

import toml
import sys
import requests
import os
import gzip
import tarfile
import shutil
from datetime import datetime
import subprocess
import zipfile
from io import BytesIO


folder_path_md2hlp = os.path.expanduser("~/.bpm/md2hlp/")

#tableau = {'fruit1': 'pomme', 'fruit2': 'banane', 'fruit3': 'orange'}

plugins_description = {
    'md2hlp': 'Build markdown into hlp file (text mode)',
    'orixsdk': 'Useful ca65 macro for Orix and reloc binary (Mandatory for Orix projects)',
    'asm_bin_tpl': 'Assembly binary template for Orix'
    }

#curl -X POST --data-binary "@requirements.txt" "http://api.orix.oric.org/v1/libtgz?version=2024.4&name=jede&key=5b5060526f28a3e8cd5b366f665dd83b"

toml_file = "bpm.tml"
user_folder = '.bpm/'

def decompress_and_extract(filename, dependency_name):
    """Décompresse un fichier .gz et extrait une archive .tar"""
    try:
        # Décompression du fichier .gz
        with gzip.open(filename, 'rb') as f_in:
            with open(filename[:-4] + ".tar", 'wb') as f_out:  # Enlève '.tgz'
                f_out.writelines(f_in)
        os.remove(filename)
        os.makedirs('orixlibs/' + dependency_name, exist_ok=True)
        # Extraction du fichier .tar
        with tarfile.open(filename[:-4] + ".tar", 'r') as tar:
            tar.extractall(path='orixlibs/'+ dependency_name)  # Extrait dans le répertoire orixlibs
        os.remove(filename[:-4] + ".tar")

    except Exception as e:
        print(f"Erreur lors de la décompression ou de l'extraction : {e}")

def add_dependency_to_toml(file_path, dependency_str):
    """Ajoute une nouvelle dépendance dans la section 'dependency' du fichier TOML"""
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Si la section "dependency" n'existe pas, la créer
        if "dependencies" not in data:
            data["dependencies"] = {}

        # Séparer le nom de la dépendance et la version
        try:
            dependency_name, dependency_version = dependency_str.split("@")
            dependency_name = dependency_name.strip()
            dependency_version = dependency_version.strip().strip('"').strip("'")
        except ValueError:
            print("Erreur de format : La chaîne doit être sous la forme 'nom@\"version\"'.")
            return

        # Ajouter ou mettre à jour la dépendance dans le fichier TOML
        data["dependencies"][dependency_name] = dependency_version

        value = download_file("http://repo.orix.oric.org/dists/" + dependency_version + "/tgz/6502/" + dependency_name + ".tgz", "orixlibs/" + dependency_name + ".tgz", dependency_name)

        if value == 0:
            # Écrire les modifications dans le fichier TOML
            with open(file_path, 'w') as file:
                toml.dump(data, file)

            print(f"{dependency_name} = {dependency_version} installed")
        else:
            print(f"{dependency_name} = {dependency_version} not found")

    except FileNotFoundError:
        print(f"Le fichier '{file_path}' n'a pas été trouvé.")
    except toml.TomlDecodeError:
        print(f"Erreur lors de la lecture du fichier TOML '{file_path}'.")

def download_file(url, local_filename, dependency_name):
    """Télécharge un fichier depuis une URL"""
    os.makedirs('orixlibs', exist_ok=True)
    try:
        response = requests.get(url)
        response.raise_for_status()  # Vérifie si la requête a réussi

        with open(local_filename, 'wb') as f:
            f.write(response.content)

        decompress_and_extract(local_filename, dependency_name)
        return 0
    except requests.exceptions.RequestException as e:
        return 1

def install_dependency_from_toml(toml_file):
    try:
        # Lire le fichier TOML
        with open(toml_file, 'r') as file:
            data = toml.load(file)

        if "dependencies" in data:
            dependencies = data["dependencies"]
            print("Liste des dépendances :")
            for key, value in dependencies.items():
                value_download = download_file("http://repo.orix.oric.org/dists/" + value + "/tgz/6502/" + key + ".tgz", "orixlibs/" + key + ".tgz", key)
                if value_download == 0:
                    print(f"{key} = {value} installed")
                else:
                    print(f"{key} = {value} not found")

    except FileNotFoundError:
        print(f"Le fichier '{toml_file}' n'a pas été trouvé.")

def read_dependencies_from_toml(file_path):
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Vérifier si la section "dependency" existe
        if "dependencies" in data:
            dependencies = data["dependencies"]
            print("Liste des dépendances :")
            for key, value in dependencies.items():
                print(f"{key} = {value}")
        else:
            print("La section 'dependencies' n'existe pas dans le fichier TOML.")
    except FileNotFoundError:
        print(f"Le fichier '{file_path}' n'a pas été trouvé.")
    except toml.TomlDecodeError:
        print(f"Erreur lors de la lecture du fichier TOML '{file_path}'.")

def remove_dependency_from_toml(file_path, dependency_name):
    """Supprime une dépendance de la section 'dependency' du fichier TOML"""
    try:
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Vérifier si la section "dependency" existe
        if "dependencies" in data and dependency_name in data["dependencies"]:
            del data["dependencies"][dependency_name]
            print(f"{dependency_name} uninstalled")
            shutil.rmtree("orixlibs/" + dependency_name)
        else:
            print(f"La dépendance '{dependency_name}' n'existe pas dans le fichier TOML.")

        # Écrire les modifications dans le fichier TOML
        with open(file_path, 'w') as file:
            toml.dump(data, file)

    except FileNotFoundError:
        print(f"Le fichier '{file_path}' n'a pas été trouvé.")
    except toml.TomlDecodeError:
        print(f"Erreur lors de la lecture du fichier TOML '{file_path}'.")

def init_toml(file_path):
    current_directory = os.getcwd()
    last_directory = os.path.basename(os.path.normpath(current_directory))
    now = datetime.now()

    # Récupérer l'année courante
    current_year = now.year

    # Déterminer le trimestre actuel
    current_month = now.month
    current_trimester = (current_month - 1) // 3 + 1

    # Afficher les résultats
    # print(f"Année courante : {current_year}")
    # print(f"Trimestre actuel : {current_trimester}")
    """Crée un fichier TOML avec des valeurs par défaut."""
    content = "[package]\nname = \"" + last_directory  + "\"\nversion = \"" + str(current_year) + "." + str(current_trimester) + "\"\nauthors = [ \"nobody@nobody.fr\" ]\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2018\"\ncpu = \"6502\"\n"
    content = content + "readme=\nrepository=\ndocumentation=\ndescription=\nhomepage=\nbuildfolder=build\npackagetype=tgz\n"
    content = content + "\n[dependencies]\n"
    with open(file_path, 'w') as file:
        file.write(content)

    if not os.path.exists("VERSION"):
        content = str(current_year) + "." + str(current_trimester)
        with open("VERSION", 'w') as file:
            file.write(content)
    print(f"initialized")

def verify_installed():
    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    if not os.path.exists(directory_path):
        # Créer le répertoire
        os.makedirs(directory_path, mode=0o755, exist_ok=True)
    if not os.path.isfile(directory_path + "/bpm"):
        # Créer le répertoire
        str_init = "oricutron_path=oricutron\n"
        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write(str_init)  # Crée un fichier vide

def search_lib(search_word: str):
    """Télécharge un fichier depuis une URL"""
    try:
        response = requests.get("http://repo.orix.oric.org/dists/official/tgz/6502/listtgz.txt")
        response.raise_for_status()  # Vérifie si la requête a réussi
        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/6502/"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory

        # Vérifier si le répertoire existe déjà
        if not os.path.exists(directory_path):
            # Créer le répertoire
            os.makedirs(directory_path, mode=0o755, exist_ok=True)

        with open(directory_path + "/listtgz.txt", 'wb') as f:
            f.write(response.content)
        if search_word == "":
            print(response.content)
        else:
            with open(directory_path + "/listtgz.txt", 'r') as file:
                for line_number, line in enumerate(file, start=1):
                    # Si le mot clé est trouvé dans la ligne
                    line_split = line.split(';')
                    if line_split[2].strip() == 'lib':
                        if search_word in line_split[0]:
                            print(line_split[0] + ' ' +line_split[1])

        return 0
    except requests.exceptions.RequestException as e:
        return 1

def lister_fichiers_s(repertoire):
    fichiers_s = [fichier for fichier in os.listdir(repertoire) if fichier.endswith('.s')]
    return fichiers_s

def build(args):
    repertoire = 'src/'
    fichiers_s = lister_fichiers_s(repertoire)

    if not os.path.exists("bmptmp/"):
        # Créer le répertoire
        os.makedirs("bmptmp/", mode=0o755, exist_ok=True)

    with open(toml_file, 'r') as file:
        data = toml.load(file)

    if "package" in data:
        package = data["package"]
        for key, value in package.items():
            if key == "codetype":
                codetype = value
                break
        for key, value in package.items():
            if key == "name":
                name = value
                break

    for fichier in fichiers_s:
        nom_sans_extension = os.path.splitext(fichier)[0]
        print("Building " + "src/" + fichier,)
        resultat = subprocess.run(['ca65', '-ttelestrat', "src/" + fichier, "-o", "bmptmp/" + nom_sans_extension + ".o", "--include-dir", "src/include"], check=True, capture_output=True, text=True)
        if codetype == "lib":
            print("Adding bmptmp/" + nom_sans_extension + ".o to " + name + ".lib")
            resultat = subprocess.run(['ar65', 'r', name + ".lib", "bmptmp/" + nom_sans_extension + ".o"], check=True, capture_output=True, text=True)
            #@$(AR) r ch395.lib $@
    #ca65 -ttelestrat $(@:.o=.s) -o $@ --include-dir src/include

def usage():
    print("Orix build and package manager\n")
    print("Usage : bpm [OPTIONS] [COMMAND]\n")
    print("\033[1;32mCommands:\033[0m")
    print("    \033[1;36mnew\033[0m             Init a new orix package")
    print("    \033[1;36minit\033[0m            Init an orix package in an existing directory")
    print("    \033[1;36mbuild\033[0m           Build")
    print("    \033[1;36mrun\033[0m             Run")
    print("    \033[1;36mlist\033[0m            List packages")
    print("    \033[1;36madd         \033[0m    Add dependencies to a manifest file")
    print("    \033[1;36mremove      \033[0m    Remove dependencies from a manifest file")
    print("    \033[1;36minstall     \033[0m    Install all dependencies from a manifest file")
    print("    \033[1;36msearch      \033[0m    Search package")
    print("    \033[1;36mpublish     \033[0m    Publish lib")
    print("    \033[1;36mplugins     \033[0m    Manage plugins")
    print("    \033[1;36mconfig      \033[0m    Manage config")

def plugins(args):
    if len(sys.argv) >= 3:
        if sys.argv[2] == "install":
            if len(sys.argv) == 4:
                if sys.argv[3] == "orixsdk":
                    install_orixsdk()
                elif sys.argv[3] == "asm_bin_tpl":
                    install_asm_bin_tpl()
                else:
                    print("Unknown plugin")
            else:
                print("Missing parameter")
        else:
            print("Unknown parameter")

    if len(sys.argv) == 2:
        for cle, valeur in plugins_description.items():
            print(f"\033[1;36m{cle}\033[0m: {valeur}", end="")
            if cle == "md2hlp":

                file_path = os.path.join(folder_path_md2hlp , "md2hlp-master/")
                if not os.path.exists(file_path):
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    print(" \033[1;32m[Installed]\033[0m")
            if cle == "orixsdk":
                folder_path_orixsdk = os.path.expanduser("~/.bpm/orixsdk/")
                file_path = os.path.join(folder_path_orixsdk , "")
                if not os.path.exists(file_path):
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    print(" \033[1;32m[Installed]\033[0m")
            if cle == "asm_bin_tpl":
                folder_path_asm_bin = os.path.expanduser("~/.bpm/tpl/asm_bin_tpl/")
                file_path = os.path.join(folder_path_asm_bin , "")
                if not os.path.exists(file_path):
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    print(" \033[1;32m[Installed]\033[0m")

def manage_config(args):
    if len(sys.argv) == 2:
        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/bpm"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory
        print("#########################")
        print("#      Main config      #")
        print("#########################")
        try:
            with open(directory_path, 'r') as fichier:
                contenu = fichier.read()
                print(contenu)
        except FileNotFoundError:
            print(f"Le fichier '{chemin_fichier}' n'a pas été trouvé.")
        except Exception as e:
            print(f"Une erreur est survenue : {e}")

def publish():
    publish_key = os.getenv('BPM_PUBLISH_KEY')

    if publish_key is None:
        print("BPM_PUBLISH_KEY is not defined")
        return 1
    #curl -X POST --data-binary "@requirements.txt" "http://api.orix.oric.org/v1/libtgz?version=2024.4&name=jede&key=X"
    fichier_chemin="requirements.txt"
    url = "http://api.orix.oric.org/v1/libtgz?version=2024.4&name=jede&key=" + publish_key


    with open(fichier_chemin, 'rb') as fichier:
        fichiers = {'file': fichier}  # Préparer le fichier pour l'envoi

        # Effectuer la requête POST
        print(fichiers)
        response = requests.post(url, files=fichiers)

def install_asm_bin_tpl():
    # Chatgpt:
    # Si le folder ~/.bpm/tpl/asm_bin_tpl/ n'existe pas, telecharge https://github.com/assinie/new-project/archive/refs/heads/main.zip, dezippe le dans ~/.bpm/tpl/
    # Définir le chemin du dossier asm_bin_tpl
    folder_path = os.path.expanduser("~/.bpm/tpl/asm_bin_tpl/")

    # Vérifier si le dossier existe
    if not os.path.exists(folder_path):
        print("Le dossier asm_bin_tpl n'existe pas, téléchargement de l'archive...")

        # Créer le dossier parent ~/.bpm/tpl/ s'il n'existe pas
        parent_folder = os.path.dirname(folder_path)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        # Télécharger l'archive depuis GitHub
        url = "https://github.com/assinie/new-project/archive/refs/heads/main.zip"
        response = requests.get(url)

        # Vérifier si le téléchargement est réussi
        if response.status_code == 200:
            print("Téléchargement réussi, décompression en cours...")

            # Décompresser l'archive
            with zipfile.ZipFile(BytesIO(response.content)) as z:
                z.extractall(parent_folder)  # Décompresser dans ~/.bpm/tpl/

            # Renommer le dossier décompressé
            extracted_folder = os.path.join(parent_folder, 'new-project-main')
            if os.path.exists(extracted_folder):
                os.rename(extracted_folder, folder_path)

            print("Décompression terminée dans", folder_path)
        else:
            print("Erreur lors du téléchargement. Code de statut:", response.status_code)
    else:
        print("Le dossier asm_bin_tpl existe déjà dans", folder_path)


def install_orixsdk():
    # Chatgpt:
    # Si le folder ~/.bpm/orixsdk/ n'existe pas, telecharge https://github.com/assinie/orix-sdk/archive/refs/heads/master.zip, dezippe le dans ~/.bpm/
    folder_path = os.path.expanduser("~/.bpm/orixsdk/")

    # Vérifier si le dossier existe
    if not os.path.exists(folder_path):
        print("Le dossier orixsdk n'existe pas, téléchargement de l'archive...")

        # Créer le dossier parent ~/.bpm/ s'il n'existe pas
        parent_folder = os.path.dirname(folder_path)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        # Télécharger l'archive depuis GitHub
        url = "https://github.com/assinie/orix-sdk/archive/refs/heads/master.zip"
        response = requests.get(url)

        # Vérifier si le téléchargement est réussi
        if response.status_code == 200:
            print("Téléchargement réussi, décompression en cours...")

            # Décompresser l'archive
            with zipfile.ZipFile(BytesIO(response.content)) as z:
                z.extractall(parent_folder)  # Décompresser dans ~/.bpm/

            # Renommer le dossier décompressé
            extracted_folder = os.path.join(parent_folder, 'orix-sdk-master')
            if os.path.exists(extracted_folder):
                os.rename(extracted_folder, folder_path)

            print("Décompression terminée dans", folder_path)
        else:
            print("Erreur lors du téléchargement. Code de statut:", response.status_code)
    else:
        print("Le dossier orixsdk existe déjà dans", folder_path)

def install_md2hlp():
    # Chatgpt:
    # Si le folder ~/.bpm/md2hlp/ n'existe pas, telecharge https://github.com/assinie/md2hlp/archive/refs/heads/master.zip, dezippe le dans ~/.bpm/md2hlp/
    print("Installing md2hlp")

    # Créer le dossier s'il n'existe pas
    if not os.path.exists(folder_path_md2hlp):
        os.makedirs(folder_path_md2hlp )

        # Télécharger l'archive depuis GitHub
    url = "https://github.com/assinie/md2hlp/archive/refs/heads/master.zip"
    response = requests.get(url)

    # Vérifier si le téléchargement est réussi
    if response.status_code == 200:
        print("Téléchargement réussi, décompression en cours...")

        # Décompresser l'archive
        with zipfile.ZipFile(BytesIO(response.content)) as z:
            z.extractall(folder_path_md2hlp )

        print("Décompression terminée dans", folder_path_md2hlp)
    else:
        print("Erreur lors du téléchargement. Code de statut:", response.status_code)

def build_doc(toml_file):
    # Test md2hlp
    # Chatgpt :

    folder_path_md2hlp = os.path.expanduser("~/.bpm/md2hlp/")
    file_path = os.path.join(folder_path_md2hlp , "")

    # Vérifier si le fichier existe
    if not os.path.exists(file_path):
        install_md2hlp()

def main():
    # Vérifier si l'argument 'list' est passé en ligne de commande
    verify_installed()

    if len(sys.argv) == 1:
        usage()
        sys.exit(1)

    if sys.argv[1] != 'build' and sys.argv[1] != 'config' and sys.argv[1] != 'd' and sys.argv[1] != 'doc' and sys.argv[1] != 'init' and sys.argv[1] != 'plugins' and sys.argv[1] != 'list' and sys.argv[1] != 'add' and sys.argv[1] != 'remove' and sys.argv[1] != 'new' and sys.argv[1] != 'install' and sys.argv[1] != '-V' and sys.argv[1] != 'search' and sys.argv[1] != 'publish':
        usage()
        sys.exit(1)

    action = sys.argv[1]

    if action == '-V':
        print("2024.4")
    elif action == 'doc' or action == 'd':
        build_doc(toml_file)
    elif action == 'list':
        read_dependencies_from_toml(toml_file)
    elif action == 'add' and len(sys.argv) == 3:
        dependency_str = sys.argv[2]
        add_dependency_to_toml(toml_file, dependency_str)
    elif action == 'remove':
        if len(sys.argv) == 3:
            dependency_name = sys.argv[2]
            remove_dependency_from_toml(toml_file, dependency_name)
        else:
            print("remove needs an argument")
    elif action == 'install':
        install_dependency_from_toml(toml_file)
    elif action == 'search':
        to_find = ""
        if len(sys.argv) == 3:
            to_find = sys.argv[2]
        search_lib(to_find)
    elif action == 'new':
        if not os.path.exists(toml_file):
            init_toml(toml_file)
        else:
            print("Already initialized")
    elif action == 'plugins':
        plugins(sys.argv)
    elif action == 'config':
        manage_config(sys.argv)
    elif action == 'build':
        build(sys.argv)
    elif action == 'init':
        if not os.path.exists(toml_file):
            init_toml(toml_file)
        else:
            print("Already initialized")
    elif action == 'publish':
        publish()

    # Lire et afficher les dépendances


if __name__ == "__main__":
    main()