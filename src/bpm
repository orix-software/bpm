#!/usr/bin/env python3

import tarfile
import toml
import sys
import requests
import os
import gzip
import shutil
from datetime import datetime
import subprocess
import platform
import zipfile
from io import BytesIO
import shutil
import glob
import urllib.parse

VERSION_BPM = "2025.4.5"

build_folder = "build"
docs_folder = "docs"

main_config_path = os.path.expanduser("~/.bpm/bpm")
folder_path_md2hlp = os.path.expanduser("~/.bpm/md2hlp/")

bin_ca65 = ['ca65']

symbs = [u'\u255a', u'\u2554', u'\u2569', u'\u2566', u'\u2560', u'\u2550', u'\u256c', u'\u2557', u'\u2551', u'\u255a', u'\u255d']

plugins_description = {
    'md2hlp': 'Build markdown into hlp file (text mode)',
    'orixsdk': 'Useful ca65 macro for Orix and reloc binary (Mandatory for Orix projects)',
    'asm_bin_tpl': 'Assembly binary template for Orix',
    'asm_rom_tpl': 'Assembly rom template for Orix',
    'github_action': 'Template for github action',
    'generatedoc': 'Tool to comment source code and generate markdown'
    }

plugins_installed = {
    'md2hlp': False,
    'orixsdk': False,
    'asm_bin_tpl': False,
    'asm_rom_tpl': False,
    'github_action': False,
    'generatedoc': False
    }

plugins_url = {
    'md2hlp': 'FIXME',
    'orixsdk': 'https://github.com/assinie/orix-sdk/archive/refs/heads/master.zip',
    'asm_bin_tpl': 'https://github.com/assinie/new-project/archive/refs/heads/main.zip',
    'asm_rom_tpl': 'https://github.com/assinie/orix-cart/archive/refs/heads/master.zip',
    'github_action': 'https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/plugins/templates/github/action/#VERSION#/main.yml',
    'generatedoc': 'https://github.com/orix-software/generatedoc/archive/refs/heads/main.zip',
}

plugins_url_version = {
    'md2hlp': 'FIXME',
    'orixsdk': 'https://raw.githubusercontent.com/assinie/orix-sdk/refs/heads/master/VERSION',
    'asm_bin_tpl': 'https://raw.githubusercontent.com/assinie/new-project/refs/heads/main/VERSION',
    'asm_rom_tpl': 'https://raw.githubusercontent.com/assinie/orix-cart/refs/heads/master/VERSION',
    'github_action': 'https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/plugins/templates/github/action/VERSION',
    'generatedoc': 'https://raw.githubusercontent.com/orix-software/generatedoc/refs/heads/main/VERSION'
}

plugins_main_property_name = {
    'md2hlp': 'default_md2hlp_version',
    'orixsdk': 'default_orixsdk_version',
    'asm_bin_tpl': 'default_asm_bin_tpl_version',
    'asm_rom_tpl': 'default_asm_rom_tpl_version',
    'github_action': 'default_github_action_version',
    'generatedoc': 'default_generatedoc_version'
}

toml_file = "bpm.tml"
user_folder = '.bpm/'

def check_binary(binary_name):
    try:
        if platform.system() == "Windows":
            result = subprocess.run(["where", binary_name], capture_output=True, text=True)
        else:
            result = subprocess.run(["which", binary_name], capture_output=True, text=True)

        if result.returncode != 0:
            print(f"Error: The binary '{binary_name}' is not in the PATH.", file=sys.stderr)
            return 1
        else:
            print(f"The binary '{binary_name}' is available: {result.stdout.strip()}")

    except Exception as e:
        print(f"Error while checking the binary: {e}", file=sys.stderr)
        return 1
    return 0

def build_without_cl65_c_files(arg_include_c, arg_include_asm, arg_ld_libs, file_to_compile_c, bpm_tmp_folder, name, force_build, binname_to_build) -> int:
    print("ici")
    if force_build == False:
        generate = False


        if not os.path.exists (bpm_tmp_folder + f'{binname_to_build}_2048.o'):
            generate = True
            force_build == True

        if force_build == False:

            generate = check_src_with_target_file(file_to_compile_c,  bpm_tmp_folder + f'{binname_to_build}_2048.o')


        if generate == False:
            return

    arg_include_c_tab = []
    arg_include_tab = arg_include_c.strip().split(' ')
    for index, valeur in enumerate(arg_include_tab):
        arg_include_c_tab.append('--include-dir')
        arg_include_c_tab.append(arg_include_tab[index])


    bin_cc65 = ['cc65', "--include-dir", "src/include"]
    arg_cc65 = [ '-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + f'{binname_to_build}_2048.s',  name + ".lib"]
    cc65_command_line_2048 = bin_cc65 + arg_include_c_tab + arg_cc65

    try:
        print(f"Compiling: {file_to_compile_c}")
        resultat = subprocess.run(cc65_command_line_2048, check=True, capture_output=False, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
        exit(1)

    arg_cc65_2304 = [ '-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + f'{binname_to_build}_2304.s',  name + ".lib"]

    cc65_command_line_2304 = bin_cc65 + arg_include_c_tab + arg_cc65_2304

    resultat = subprocess.run(cc65_command_line_2304, check=True, capture_output=False, text=True)

    arg_include_asm_tab = arg_include_asm.strip().split(' ')
    arg_ca65_array = []
    for index, valeur in enumerate(arg_include_asm_tab):
        arg_ca65_array.append('-I ' + arg_include_asm_tab[index])

    print(" Assembling ...")

    try:
        arg_ca65 = ["-I", "src/include", '-ttelestrat', bpm_tmp_folder + f'{binname_to_build}_2048.s', "-o", bpm_tmp_folder + f'{binname_to_build}_2048.o' ]
        resultat = subprocess.run(bin_ca65 + arg_ca65_array + arg_ca65, check=True, capture_output=False, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
        exit(1)

    arg_ca65 = ["-I", "src/include",  '-ttelestrat', bpm_tmp_folder + f'{binname_to_build}_2304.s', "-o", bpm_tmp_folder + f'{binname_to_build}_2304.o' ]
    resultat = subprocess.run(bin_ca65 + arg_ca65_array + arg_ca65, check=True, capture_output=False, text=True)

    ld65_command_line_list_lib = []

    if os.path.exists(name + ".lib"):
        ld65_command_line_list_lib.append(name + ".lib")

    ld65_command_line = []

    arg_ld_libs_tab = []


    arg_ld_libs_split = arg_ld_libs.strip().split(' ')
    for index, valeur in enumerate(arg_ld_libs_split):
        arg_ld_libs_tab.append(valeur)

    arg_ld_libs_tab.append("telestrat.lib")
    print(" Linking ...")

    arg_ld65 = ['ld65', '-ttelestrat', bpm_tmp_folder + f'{binname_to_build}_2048.o', "-o", bpm_tmp_folder + f'{binname_to_build}_2048', '--start-addr',  f'2048']

    try:
        resultat = subprocess.run(arg_ld65 + arg_ld_libs_tab, check=True, capture_output=False, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
        exit(1)

    arg_ld65 = ['ld65', '-ttelestrat', bpm_tmp_folder + f'{binname_to_build}_2304.o', "-o", bpm_tmp_folder + f'{binname_to_build}_2304', '--start-addr', f'2304']
    resultat = subprocess.run(arg_ld65 + arg_ld_libs_tab, check=True, capture_output=False, text=True)

def convert_binary_name_to_seven_chars(name) -> str:
    if len(name) > 7:
        print(f"Warn : name is greater than 7 chars. binary name is truncated for Orix. Binary name will be : {name[:7]}")
    return name[:7]


def decompress_and_extract(filename, dependency_name):
    """Décompresse un fichier .gz et extrait une archive .tar"""
    try:
        # Décompression du fichier .gz
        with gzip.open(filename, 'rb') as f_in:
            with open(filename[:-4] + ".tar", 'wb') as f_out:  # Enlève '.tgz'
                f_out.writelines(f_in)
        os.remove(filename)
        os.makedirs('orixlibs/' + dependency_name, exist_ok=True)
        # Extraction du fichier .tar
        with tarfile.open(filename[:-4] + ".tar", 'r') as tar:
            tar.extractall(path='orixlibs/'+ dependency_name)  # Extrait dans le répertoire orixlibs
        os.remove(filename[:-4] + ".tar")

    except Exception as e:
        print(f"Decrunching error : {e}")

def read_local_config_file():
    file_path = "bpm.tml"
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)
        # Vérifier si la section "srcfolders" existe
        if 'srcfolders' not in data:
            # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
            data['srcfolders'] = {}
            with open(file_path, 'w') as file:
                toml.dump(data, file)
        return data

    except FileNotFoundError:
        print(f"'{file_path}' not found")
    except toml.TomlDecodeError:
        print(f"Impossible to read d'{file_path}'.")


def add_dependency_to_toml(file_path, dependency_str):
    """Ajoute une nouvelle dépendance dans la section 'dependency' du fichier TOML"""
    if dependency_str == "-h":
        print("bpm add package@version")
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Si la section "dependency" n'existe pas, la créer
        if "dependencies" not in data:
            data["dependencies"] = {}

        # Séparer le nom de la dépendance et la version
        try:
            dependency_name, dependency_version = dependency_str.split("@")
            dependency_name = dependency_name.strip()
            dependency_version = dependency_version.strip().strip('"').strip("'")
        except ValueError:
            print("Format error : parameter must be : 'nom@\"version\"'.")
            return

        # Ajouter ou mettre à jour la dépendance dans le fichier TOML
        data["dependencies"][dependency_name] = dependency_version
        dependency_file = dependency_name + "lib"
        value = download_file("http://repo.orix.oric.org/dists/" + dependency_version + "/tgz/6502/" + dependency_file + ".tgz", "orixlibs/" + dependency_name + ".tgz", dependency_name)

        if value == 0:
            # Écrire les modifications dans le fichier TOML
            with open(file_path, 'w') as file:
                toml.dump(data, file)

            print(f"{dependency_name} = {dependency_version} installed")
        else:
            print(f"{dependency_name} = {dependency_version} not found")

    except FileNotFoundError:
        print(f"'{file_path}' nnot found")

    except toml.TomlDecodeError:
        print(f"Impossible to read '{file_path}'.")


def download_file(url, local_filename, dependency_name):
    """Télécharge un fichier depuis une URL"""
    os.makedirs('orixlibs', exist_ok=True)
    try:
        response = requests.get(url)
        response.raise_for_status()  # Vérifie si la requête a réussi

        with open(local_filename, 'wb') as f:
            f.write(response.content)

        decompress_and_extract(local_filename, dependency_name)
        return 0

    except requests.exceptions.RequestException as e:
        return 1


def install_dependency_from_toml(args):

    if len(args) == 3:
        if args[2] == "-h":
            print("Install all dependencies\n")
            print("Usage : bpm install\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36minstall\033[0m             Install all dependencies for this project")
            return 0

    try:
    # Lire le fichier TOML
        data = read_local_config_file()

        if "dependencies" in data:
            dependencies = data["dependencies"]
            if len(data["dependencies"]) == 0:
                print("No dependencies")
                return 0
            if len(dependencies) != 0:
                print("Dependencies:")
                for key, value in dependencies.items():
                    value_download = download_file("http://repo.orix.oric.org/dists/" + value + "/tgz/6502/" + key + ".tgz", "orixlibs/" + key + ".tgz", key)
                    if value_download == 0:
                        print(f"{key} = {value} installed")
                    else:
                        print(f"{key} = {value} not found")

    except FileNotFoundError:
        print(f"'{toml_file}' not found")

def read_dependencies_from_toml():
    try:
        # Lire le fichier TOML
        data = read_local_config_file()

        # Vérifier si la section "dependency" existe
        if "dependencies" in data:
            dependencies = data["dependencies"]
            if len(dependencies) != 0:
                print("Dependencies list :")
            else:
                print("No dependencies")
            for key, value in dependencies.items():
                print(f"{key} = {value}")
        else:
            print("'dependencies' section does not exists in bpm.tml")
    except FileNotFoundError:
        print(f"file not found : 'bpm.tml'")
    except toml.TomlDecodeError:
        print(f"Read error :  'bpm.tml'.")

def trim_after_second_dot(version):
    return '.'.join(version.split('.')[:2])

def remove_dependency_from_toml(dependency_name):
    """Supprime une dépendance de la section 'dependency' du fichier TOML"""
    try:
        data = read_local_config_file()
    except FileNotFoundError:
        print("'bpm.tml' not found")
    except toml.TomlDecodeError:
        print("Impossible to read 'bpm.tml'.")

    # Vérifier si la section "dependency" existe
    if "dependencies" in data and dependency_name in data["dependencies"]:
        del data["dependencies"][dependency_name]
        print(f"{dependency_name} uninstalled")
        if os.path.isfile("orixlibs/" + dependency_name):
            shutil.rmtree("orixlibs/" + dependency_name)
        # Écrire les modifications dans le fichier TOML
        with open(toml_file, 'w') as file:
            toml.dump(data, file)
    else:
        print(f"'{dependency_name}' dependency does not exist in bpm.tml")


def init_toml(args):
    if len(args) == 3:
        if args[2] == '-h':
            print("Init project\n")
            print("Usage : bpm init\n")
            return

    code_template = ""

    if os.path.exists(toml_file):
        print("Already initialized")
        return 0
    codetype = 'bin'
    answer = input(f"This project is :\n1) A binary program\n2) A library\n3) A rom\nanswer ?")

    if answer == '2':
        codetype = 'lib'

    if answer == '3':
        is_rom_template = input(f"Do you want to use prebuild template (n/Y)\nanswer :")
        if is_rom_template == 'Y':
            plugins_detect("no_display")
            if plugins_installed['asm_rom_tpl'] == False:
                print("Please install asm_rom_tpl plugin")
                return 1
            if plugins_installed['orixsdk'] == False:
                print("Please install orixsdk plugin")
                return 1
            code_template = "asm_rom_tpl"
        codetype = 'rom'

    current_directory = os.getcwd()
    last_directory = os.path.basename(os.path.normpath(current_directory))
    now = datetime.now()

    # Récupérer l'année courante
    current_year = now.year

    # Déterminer le trimestre actuel
    current_month = now.month
    current_trimester = (current_month - 1) // 3 + 1

    if not os.path.exists(".gitignore"):
        print("Init .gitignore")
        content = f"bpmtmp/\n{build_folder}\norixlibs\n{last_directory}.lib\n"
        with open(".gitignore", 'w') as file:
            file.write( content)

    #oricutron_replace_autoboot_run

    main_config_data = read_main_config_file()

    default_asm_bin_tpl_version = ""
    default_asm_rom_tpl_version = ""
    default_orixsdk_version = ""
    oricutron_replace_autoboot_run_for_project = ""

    if "main" in main_config_data:
        main_properties = main_config_data["main"]
        default_asm_bin_tpl_version = main_properties["default_asm_bin_tpl_version"]
        default_asm_rom_tpl_version = main_properties["default_asm_rom_tpl_version"]
        default_orixsdk_version = main_properties["default_orixsdk_version"]
        default_generatedoc_version = main_properties["default_generatedoc_version"]
        default_github_action_version = main_properties["default_github_action_version"]
        default_kernel_version = main_properties["default_kernel_version"]
        oricutron_replace_autoboot_run_for_project = main_properties["oricutron_replace_autoboot_run"]


    if not os.path.exists("bpm.tml"):
        print("Init bpm.tml")
        """Crée un fichier TOML avec des valeurs par défaut."""
        version = str(current_year) + "." + str(current_trimester)
        content = "[package]\nname = \"" + last_directory  + "\"\nversion = \"" + version + "\"\nauthors = [ \"nobody@nobody.fr\" ]\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2018\"\ncpu = \"6502\"\n"
        content = content + f"readme = \"\"\nrepository = \"\"\ndocumentation = \"\"\ndescription = \"\"\nhomepage = \"\"\nbuildfolder = \"build\"\npackagetype = \"tgz,opk\"\ncodetype = \"{codetype}\"\ntemplatecode = \"{code_template}\"\npathsrc = \"src\"\n"
        content = content + f"oricutron_replace_autoboot_run = \"{oricutron_replace_autoboot_run_for_project}\"\n"
        content = content + f"asm_bin_tpl_version = \"{default_asm_bin_tpl_version}\"\n"
        content = content + f"asm_rom_tpl_version = \"{default_asm_rom_tpl_version}\"\n"
        content = content + f"orixsdk_version = \"{default_orixsdk_version}\"\n"
        content = content + f"default_github_action_version = \"{default_github_action_version}\"\n"
        content = content + f"default_generatedoc_version = \"{default_generatedoc_version}\"\n"
        content = content + f"orix_minimal_kernel_version = \"{default_kernel_version}\"\n"
        content = content + f"orix_run_pre_script = \"\"\n"
        content = content + f"md2hlp = \"yes\"\n"
        content = content + "\n[dependencies]\n\n[dynamiclibs]\n"

        # Srcfolders section
        content = content + "[srcfolders]\n"
        with open("bpm.tml", 'w') as file:
            file.write(content)

    if not os.path.exists("src"):
        print("Init src folder")
        os.makedirs("src", mode=0o755, exist_ok=True)

    if not os.path.exists(f"{docs_folder}"):
        os.makedirs(f"{docs_folder}", mode=0o755, exist_ok=True)

    if codetype == 'bin':
        if not os.path.exists("src/" + last_directory + ".c"):
            print("Init " + "src/" + last_directory + ".c")
            content = "#include <stdio.h>\n\nint main() {\n    printf(\"Hello world Orix\");\n    return 0;\n}\n"
            with open("src/" + last_directory + ".c", 'w') as file:
                file.write(content)

    if codetype == 'lib':
        if not os.path.exists("src/dynamic_lib/"):
            os.makedirs("src/dynamic_lib/", mode=0o755, exist_ok=True)
            content = f"{last_directory}_mapping_dynlib:\n.asciiz \"dynlib_{last_directory}]\"\n; Include version\n.asciiz \"{version}\"\n.byt 0 ; Module version\n.byt 0 ; ROM RAM ?\n.addr {last_directory}_startup_dynlib ; {last_directory}_startup_dynlib Init will be always 0\n.proc {last_directory}_startup_dynlib\nrts\n.endproc"
            with open("src/dynamic_lib/" + last_directory + ".s", 'w') as file:
                file.write(content)

    if not os.path.exists("VERSION"):
        print("Init VERSION file")
        content = str(current_year) + "." + str(current_trimester)
        with open("VERSION", 'w') as file:
            file.write(content)

    if code_template == "asm_rom_tpl" and codetype == 'rom':
        if default_asm_rom_tpl_version == "":
            print("Fatal 'default_asm_rom_tpl_version' can be empty in ~/.bpm/bpm")
        default_orixsdk_version_truncated = trim_after_second_dot(default_orixsdk_version)
        add_dependency_to_toml(toml_file, f"orixsdk@{default_orixsdk_version_truncated}")
        folder_path_rom_bin = os.path.expanduser(f"~/.bpm/plugins/asm_rom_tpl/{default_asm_rom_tpl_version}/orix-cart-master/")
        if not os.path.exists("macros"):
            os.makedirs("macros", mode=0o755, exist_ok=True)
            shutil.copy(folder_path_rom_bin + "macros/rom_cmd.mac", "macros/rom_cmd.mac")
        shutil.copy(folder_path_rom_bin + "src/rom_cmd.s", f"src/{last_directory}.s")

    if plugins_installed['github_action'] == True:
        answer = input(f"Add github action main.yml into project: y/N ?")
        if answer == 'y':
            os.makedirs(".github/workflows/", exist_ok=True)
            home_directory = os.path.expanduser(f'~/.bpm/plugins/github_action/{default_github_action_version}/')
            shutil.copy(home_directory + "main.yml", ".github/workflows/main.yml")

    print(f"initialized")

def check_update_bpm(auto_update: bool):
    # Function which test if bpm can be updated
    answer = ""
    today = datetime.today()

    # # Formater la date au format YYYY-MM-DD
    today_format = today.strftime("%Y-%m-%d")

    main_config_data = read_main_config_file()

    if "main" in main_config_data:
        main_properties = main_config_data["main"]
        main_properties.setdefault("last_check_update", "0000-00-00")
        main_properties.setdefault("bpm_version", VERSION_BPM)

    if today_format == main_properties["last_check_update"] and auto_update == False:
        return 0

    print("Checking if an update is available (Last check : " + main_config_data["main"]["last_check_update"] + ") ...\n")
    get_version_bpm = "https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/VERSION"
    try:
        response = requests.get(get_version_bpm)
        response.raise_for_status()  # Vérifie si la requête a réussi
        online_version = response.content.decode('utf-8')

        if online_version.replace("\n", "") != main_config_data["main"]["bpm_version"]:
            current_version = main_config_data["main"]["bpm_version"]
            if auto_update == False:
                answer = input(f"A new version of bpm is available.\nCurrent version : {current_version}, Available version : \033[1;36m{online_version}\033[0m .\n if you want to install it, type 'update' or else type 'skip' : \n[update/skip] ? ")

    except requests.exceptions.RequestException as e:
        print("Can not check if a new version of 'bpm' is not available")
        return 1
    main_properties["last_check_update"] = today_format

    if answer == "update" or auto_update == True:
        get_src_bpm = "https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/src/bpm"
        try:
            response = requests.get(get_src_bpm)
            src_code = response.content.decode('utf-8')
            current_bpm_path = os.path.abspath(__file__)
            print(f"Updating to {online_version}")
            try:
                with open(current_bpm_path, 'w') as fichier:
                    fichier.write(src_code)
                main_properties["bpm_version"] = online_version
                main_properties["last_check_update"] = today_format
                print("Updated")
            # Afficher toutes les exceptions qui se produisent
            except Exception as e:
                print(f"Une erreur est survenue lors de l'écriture : {e}")

        except requests.exceptions.RequestException as e:
            print("Can not update")
            return 1

    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    try:
        # Update file
        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write( "[main]\n")
            for key, value in main_properties.items():
                fichier.write(f"{key} = \"{value}\"\n")
    except FileNotFoundError:
        print(f"'{main_config_path}' not found")

def verify_installed():
    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    if not os.path.exists(directory_path):
        # Créer le répertoire
        os.makedirs(directory_path, mode=0o755, exist_ok=True)
    if not os.path.isfile(directory_path + "/bpm"):
        # Créer le répertoire
        str_init = "[main]\noricutron_path = \"oricutron\"\noricutron_replace_autoboot_run = \"True\"\ndefault_rom_oricutron_for_code = 4\n"
        str_init = str_init + "bpm_version = \"" + VERSION_BPM + "\"\n"
        str_init = str_init + "last_check_update = \"0000-00-00\"\n"
        str_init = str_init + "default_orixsdk_version = \"\"\n"
        str_init = str_init + "default_asm_bin_tpl_version = \"\"\n"
        str_init = str_init + "default_asm_rom_tpl_version = \"\"\n"
        str_init = str_init + "default_github_action_version = \"\"\n"
        str_init = str_init + "default_kernel_version = \"2024.1\"\n"
        str_init = str_init + "default_generatedoc_version = \"\"\n"


        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write(str_init)  # Crée un fichier vide


def addsrc(args):
    if len(args) == 3:
        if args[2] == '-h':
            print("Add a source folder\n")
            print("Usage : bpm addsrc folder\n")
            return

    if len(args) == 3:
        data = read_local_config_file()
        folder = args[2]
        if 'srcfolders' in data:
            # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
            data['srcfolders'][folder] = folder
            file_path = "bpm.tml"
            with open(file_path, 'w') as file:
                toml.dump(data, file)


def search_lib(search_word: str):

    """Télécharge un fichier depuis une URL"""

    try:
        response = requests.get("http://repo.orix.oric.org/dists/official/tgz/6502/listtgz.txt")
        response.raise_for_status()  # Vérifie si la requête a réussi
        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/6502/"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory

        # Vérifier si le répertoire existe déjà
        if not os.path.exists(directory_path):
            # Créer le répertoire
            os.makedirs(directory_path, mode=0o755, exist_ok=True)

        content = ""
        for line in response.iter_lines():
            if line:  # Pour éviter les lignes vides
                content = content + line.decode('utf-8') + '\n'

        with open(directory_path + "/listtgz.txt", 'wb') as f:
            f.write(response.content)
        if search_word == "":
            content = content.replace(';lib', ' - ')  # Retirer ";lib"
            content = content.replace(';', ' ')    # Remplacer ; par des espaces
            print(content)
        else:
            with open(directory_path + "/listtgz.txt", 'r') as file:
                for line_number, line in enumerate(file, start=1):
                    # Si le mot clé est trouvé dans la ligne
                    line_split = line.split(';')
                    if line_split[2].strip() == 'lib':
                        if search_word in line_split[0]:
                            print(line_split[0] + ' ' +line_split[1])

        return 0
    except requests.exceptions.RequestException as e:
        return 1

def build_package(source_dir, output_filename, name, version):
    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 1

    build_bpm_etc_path = f"{build_folder}/etc/bpm/{name}/{version}"

    if not os.path.exists(build_bpm_etc_path):
        # Créer le répertoire
        os.makedirs(build_bpm_etc_path, mode=0o755, exist_ok=True)

    if not os.path.exists(f"{build_folder}/usr/share/{name}/{version}"):
        # Créer le répertoire
        os.makedirs(f"{build_folder}/usr/share/{name}/{version}", mode=0o755, exist_ok=True)

    if not os.path.exists(f"src/include"):
        # Créer le répertoire
        os.makedirs(f"{build_folder}/usr/include", mode=0o755, exist_ok=True)

    if not os.path.exists(f"{build_folder}/usr/include/asm"):
        # Créer le répertoire
        os.makedirs(f"{build_folder}/usr/include/asm", mode=0o755, exist_ok=True)

    if os.path.exists(f"src/include/"):
        source_dir = "src/include/"
        destination_dir = f"{build_folder}/usr/include/asm"

        # Récupère tous les fichiers .inc dans le répertoire source
        for file_path in glob.glob(os.path.join(source_dir, "*.inc")):
            # Copie chaque fichier vers le répertoire de destination
            shutil.copy(file_path, destination_dir)

        for file_path in glob.glob(os.path.join(source_dir, "*.mac")):
            # Copie chaque fichier vers le répertoire de destination
            shutil.copy(file_path, destination_dir)

    if os.path.exists(f"src/include/"):
        source_dir = "src/include/"
        destination_dir = f"{build_folder}/usr/include/"

        for root, _, files in os.walk(source_dir):
            for file in files:
                if file.endswith(".h"):  # Filtrer les fichiers .h
                    full_path = os.path.join(root, file)
                    extracted = full_path.split(source_dir, 1)[1]
                    before_last_slash, _, _ = extracted.rpartition("/")
                    if not os.path.exists(f"{destination_dir}/{before_last_slash}"):
                        # Créer le répertoire
                        os.makedirs(f"{destination_dir}/{before_last_slash}", mode=0o755, exist_ok=True)
                    print(f"{destination_dir}/{extracted}")
                    shutil.copy(full_path, f"{destination_dir}/{extracted}")

        # Récupère tous les fichiers .inc dans le répertoire source
        #for file_path in glob.glob(os.path.join(source_dir, "*.h")):
            # Copie chaque fichier vers le répertoire de destination
            # print(f"Copy {file_path} to {destination_dir}")
            # shutil.copy(file_path, destination_dir)

    if os.path.exists("README.md"):
        shutil.copy("README.md", f"{build_folder}/usr/share/{name}/{version}/README.md")

    shutil.copy("bpm.tml", f"{build_folder}/etc/bpm/{name}/{version}/bpm.tml")
    # with tarfile.open(output_filename, "w:gz") as tar:
    #     tar.add(source_dir, arcname=os.path.basename(source_dir))
    print("Building package tgz ...")
    with tarfile.open(output_filename, "w:gz") as tar:
        for item in os.listdir(f"{build_folder}"):
            item_path = os.path.join(f"{build_folder}", item)
            # Ajoute chaque fichier ou sous-répertoire sans inclure le répertoire racine `build`
            tar.add(item_path, arcname=item)

    # Build package opk
    package_name_opk = output_filename.replace(".tgz", ".opk")
    package_name_opk_tar = output_filename.replace(".tgz", ".tar")
    #  --format=ustar
    with tarfile.open(package_name_opk_tar, "w") as tar:
        for item in os.listdir(f"{build_folder}"):
            item_path = os.path.join(f"{build_folder}", item)
            # Ajoute chaque fichier ou sous-répertoire sans inclure le répertoire racine `build`
            tar.add(item_path, arcname=item)


    # Format should be :
    # OK : Magic token
    # 0 : version 0 (means offset for zx02 max 256 bytes)
    # 4 bytes : cksum


    if check_binary('zx02') == 1:
        print(f"error: binary 'zx02' not found. Can't build .opk package.")
        return 1

    print("Building package opk ...")
    if os.path.exists(package_name_opk):
        os.remove(package_name_opk)
    try:
        result = subprocess.run(
            ["zx02", "-m", "255", package_name_opk_tar, package_name_opk],
            capture_output=True,
            text=True,
            check=True  # Lève une exception si le code de retour ≠ 0
        )
        print("Sortie :", result.stdout)
    except subprocess.CalledProcessError as e:
        print(f"Error (code {e.returncode}) :")
        print(e.stderr)
    except FileNotFoundError:
        print("error: zx02 tool not found. Please install it to build .opk packages: https://github.com/dmsc/zx02")




def lister_fichiers_s(repertoire):
    fichiers_s = [fichier for fichier in os.listdir(repertoire) if fichier.endswith('.s')]
    return fichiers_s


def compile(name, arg_include, folder):
    print(f"Building additionnal folder : {folder}")
    bin_ca65 = ['ca65']
    fichier_o = ""
    folder = folder + "/"
    absolute_path = os.path.abspath("")

    for fichier in os.listdir(folder):
        assembly = False

        # Vérifier si le fichier a l'extension .md
        if fichier.endswith(".s") or fichier.endswith(".c") or fichier.endswith(".asm"):
            if  os.path.exists(folder + fichier):
                assembly = True
                fichier_o = fichier.replace(".s", ".o")
            else:
                fichier_o = fichier.replace(".c", ".o")

            generate = check_src_with_target_file(folder + fichier, f"{absolute_path}/bpmtmp/" + fichier_o)

            if generate == True:
                arg_ca65 = ['-ttelestrat', folder + fichier, "-o", f"{absolute_path}/bpmtmp/" + fichier_o]

                if assembly == True and fichier != name + ".s":
                    print(f"File : {folder + fichier}")
                    resultat = subprocess.run(bin_ca65 + arg_include + arg_ca65, check=True, capture_output=False, text=True)
                    resultat = subprocess.run(['ar65', 'r', name + ".lib", f"{absolute_path}/bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)

                if assembly == False and fichier != name + ".c":
                    resultat = subprocess.run(bin_ca65 + arg_include + arg_ca65 , check=True, capture_output=False, text=True)
                    resultat = subprocess.run(['ar65', 'r', name + ".lib", f"{absolute_path}/bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
            else:
                print(f"[INFO] {fichier} not built")


def generate_lib_for_bin(name: str, arg_include, arg_include_asm: str):

    # This code read bpm.tml and keep additionnal binary in order to exclude them from lib generation
    file_path = "bpm.tml"
    with open(file_path, "r") as file:
        data = toml.load(file)

    print("Generate lib for binary ...")
    bin_ca65 = ['ca65']
    data = read_local_config_file()
    if 'srcfolders' in data:
        # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
        for key, value in data['srcfolders'].items():
            print("compile")
            compile(name, arg_include, key)

    nb_of_files = 0
    arg_include_asm_for_ca65 = []

    arg_include_asm_tab = arg_include_asm.strip().split(' ')
    arg_ca65_array = []
    for index, valeur in enumerate(arg_include_asm_tab):
        arg_include_asm_for_ca65.append('-I ' + arg_include_asm_tab[index])


    for fichier in os.listdir("src/"):
        # Checking if the file is in bin section
        exclude_from_lib = False
        if "bin" in data:
            print(data["bin"])
            for bin_entry in data["bin"]:
                binname = bin_entry["name"]
                key = f"path_{binname}"

                if bin_entry[key] == f"src/{fichier}":
                    exclude_from_lib = True
                    break


        if exclude_from_lib == False:
            assembly = False
            # Vérifier si le fichier a l'extension .md
            if fichier != name + ".c":
                if fichier.endswith(".s") or fichier.endswith(".c") or fichier.endswith(".asm"):
                    if fichier.endswith(".s"):
                        assembly = True
                        fichier_o = fichier.replace(".s", ".o")
                        print(f"Build src/{fichier} to {build_folder}/{fichier_o}")
                    else:
                        fichier_o = fichier.replace(".c", ".o")

                    arg_ca65 = ['-ttelestrat', "src/" + fichier, "-o", "bpmtmp/" + fichier_o]


                    if assembly == True:
                        try:
                            resultat = subprocess.run(bin_ca65 + arg_include_asm_for_ca65 + arg_ca65, check=True, capture_output=False, text=True)
                        except subprocess.CalledProcessError as e:
                            print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                            return -1

                        resultat = subprocess.run(['ar65', 'r', name + ".lib", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
                        nb_of_files = nb_of_files + 1

                    if assembly == False:
                        try:
                            resultat = subprocess.run(bin_ca65 + arg_include_asm_for_ca65 + arg_ca65, check=True, capture_output=False, text=True)
                        except subprocess.CalledProcessError as e:
                            print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                            return -1
                        resultat = subprocess.run(['ar65', 'r', name + ".lib", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
                        nb_of_files = nb_of_files + 1



    return nb_of_files

def check_src_with_target_file(filesrc: str, object_file:str) -> bool:
    generate = False

    if os.path.exists(object_file):


        time_filebuild = int(os.path.getmtime(object_file))

        time_filesrc = int(os.path.getmtime(filesrc))

        if  time_filesrc > time_filebuild:
            generate = True
    else:
        generate = True

    return generate


def fix_toml_file(key, value):
    with open("bpm.tml", "r") as fichier:
        data = toml.load(fichier)

    # Vérifier et créer la propriété si nécessaire
    if "package" not in data:
        data["package"] = {}
    if key not in data["package"]:
        data["package"][key] = value

    # Sauvegarder les modifications
    with open("bpm.tml", "w") as fichier:
        toml.dump(data, fichier)

def build(args):

    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 1

    # Detect orixsdk version
    orixsdk_version = "2023.3.0"
    generate_all = False
    LD_FLAGS = []

    repertoire = 'src/'
    fichiers_s = lister_fichiers_s(repertoire)
    bpm_tmp_folder = "bpmtmp/"

    if shutil.which("cl65") is None:
        print("Error: cl65 is not installed")
        return 1

    if shutil.which("ar65") is None:
        print("Error: ar65 is not installed")
        return 1

    # Checking if .h or .inc are modifyed
    # if it's modifyed, generate all files
    val = False
    # Parcourir l'arborescence des répertoires
    for root, dirs, files in os.walk("src/include"):
        for file in files:
            # Ajouter le chemin complet du fichier à la liste
            file_path = os.path.join(root, file)
            if not os.path.exists(f"bpmtmp/{file_path}"):
                dst_dir = os.path.dirname(f"bpmtmp/{file_path}")
                os.makedirs(dst_dir, exist_ok=True)
                shutil.copy2(file_path, f"bpmtmp/{file_path}")
                generate_all = True
                break
            val = check_src_with_target_file(file_path, f"bpmtmp/{file_path}")

            if val == True:
                dst_dir = os.path.dirname(f"bpmtmp/{file_path}")
                os.makedirs(dst_dir, exist_ok=True)
                shutil.copy2(file_path, f"bpmtmp/{file_path}")
                generate_all = True
                break

    if not os.path.exists(bpm_tmp_folder):
        # Créer le répertoire
        os.makedirs(bpm_tmp_folder, mode=0o755, exist_ok=True)

    if not os.path.exists(f"{build_folder}"):
        os.makedirs(f"{build_folder}", mode=0o755, exist_ok=True)

    data = read_local_config_file()

    dynamic_lib_name_module = ""
    codetype = ""
    if "package" in data:
        codetype = data["package"]["codetype"]
        name = data["package"]["name"]
        version = data["package"]["version"]
        if "dynamic-lib-name-module" in data.get("package", {}):
            dynamic_lib_name_module = data["package"]["dynamic-lib-name-module"]


        if "package" not in data or "templatecode" not in data["package"]:
            fix_toml_file("templatecode", "")
            print("Missing 'templatecode' property in bpm.tml... Fixed")

        else:
            templatecode = data["package"]["templatecode"]

        if "asm_bin_tpl_version" in data["package"]:
            asm_bin_tpl_version = data["package"]["asm_bin_tpl_version"]
        else:
            asm_bin_tpl_version = ""

        if "asm_rom_tpl_version" in data["package"]:
            asm_rom_tpl_version = data["package"]["asm_rom_tpl_version"]
        else:
            asm_rom_tpl_version = ""

        if "orixsdk_version" in data["package"]:
            orixsdk_version  = data["package"]["orixsdk_version"]
        else:
            orixsdk_version = ""
            if codetype != "lib":
                print("Error : 'orixsdk_version' plugin is not installed available into package section of bpm.tml, it's required to produce reloc binary, set it to version installed (see bpm plugins)")
                return 1

    else:
        print("Missing package section in bpm.tml")
        exit(1)

    if not os.path.exists(f"{build_folder}/usr/share/{name}/{version}"):
        os.makedirs(f"{build_folder}/usr/share/{name}/{version}", mode=0o755, exist_ok=True)

    arg_include_c = ""
    arg_include = ""
    arg_ld_libs = ""
    arg_include_asm = ""

    user_folder = os.path.expanduser('~')
    reloc_bin_path = f"{user_folder}/.bpm/plugins/orixsdk/{orixsdk_version}/orix-sdk-master/bin/relocbin.py3"

    if "dependencies" in data and data["dependencies"]:
        dependencies = data["dependencies"]
        if len(dependencies) != 0:
            print(f"{len(dependencies)} Dependencies detected ...")
            for key, value in dependencies.items():
                file_to_compile_c = repertoire + name + ".c"
                if os.path.exists(file_to_compile_c):
                    arg_include_c = arg_include_c + f" orixlibs/{key}/usr/include/"
                    arg_ld_libs = arg_ld_libs + f"orixlibs/{key}/usr/share/{key}/{value}/{key}.lib "
                else:
                    # Assembly file
                    #arg_include = arg_include + "-I "
                    #arg_include = arg_include + f" orixlibs/{key}/usr/include/asm/"
                   #arg_include_asm.append("--asm-include-dir")
                    arg_include_asm = arg_include_asm + f"orixlibs/{key}/usr/include/asm/ "
#                llo_detected = False
                #if data["dynamiclibs"] and "dynamiclibs" in data and  key in data["dynamiclibs"]:
                # if "dynamiclibs" in data:
                #     # orixlibs/curl/usr/share/curl/2025.1/
                #     if data["dynamiclibs"] and key in data["dynamiclibs"]:
                #         arg_ld_libs.append(f"orixlibs/{key}/usr/lib/{key}/{value}/llo/{key}.lib")
#                        llo_detected = True

                # if llo_detected == False:
                #     arg_ld_libs.append(f"orixlibs/{key}/usr/share/{key}/{value}/{key}.lib")


    path_etc_bpm = f"{build_folder}/etc/bpm"

    if not os.path.exists(f"{path_etc_bpm}/{version}"):
        #build/etc/bpm/file/2024.4/
        print(f"Creating {path_etc_bpm}/{name}/{version}")
        os.makedirs(f"{path_etc_bpm}/{name}/{version}", mode=0o755, exist_ok=True)

    shutil.copy("bpm.tml", f"{path_etc_bpm}/{name}/{version}/bpm.tml")


    plugins_detect("no_display")
    if plugins_installed['orixsdk']:
        home_directory = os.path.expanduser('~')
        path_orixsdk = f"{home_directory}/.bpm/plugins/orixsdk/{orixsdk_version}/orix-sdk-master/macros/"
        arg_include = arg_include + "-I "
        arg_include = arg_include + path_orixsdk

        #arg_include_asm.append("--asm-include-dir")
        arg_include_asm = arg_include_asm + f"{home_directory}/.bpm/plugins/orixsdk/{orixsdk_version}/orix-sdk-master/macros/ "

    if codetype == "rom":
        rom_path = f"{build_folder}/usr/share/{name}/{version}/"
        if not os.path.exists(rom_path):
            os.makedirs(rom_path, mode=0o755, exist_ok=True)
        if templatecode == "asm_rom_tpl":

            if  os.path.exists(f"macros"):
                arg_include = arg_include + "-I"
                arg_include = arg_include + f" ."

            home_directory = os.path.expanduser('~')
            path_orixsdk = f"{home_directory}/.bpm/plugins/asm_rom_tpl/{asm_rom_tpl_version}/orix-cart-master/cfg/rom.cfg"
            LD_FLAGS.append('-C')
            LD_FLAGS.append(path_orixsdk)

        err = generate_lib_for_bin(name, arg_include, arg_include_asm)

        if err == -1:
            print("Error during lib generation")
            return 1

        nom_sans_extension = name
        file_to_compile_s = repertoire + name + ".s"
        print(f"Build : {file_to_compile_s}")
        cmd_cl65 = ['ca65']
        arg_cl65 = ['-ttelestrat', file_to_compile_s, "-o", bpm_tmp_folder + name + ".ld65", "--include-dir", "src/include"]
        resultat = subprocess.run(cmd_cl65 + arg_include + arg_cl65, check=True, capture_output=False, text=True)


        cmd_ld65 = ['ld65']
        if templatecode == "asm_rom_tpl":
            arg_ld65 = [ bpm_tmp_folder + name + ".ld65", "-o", bpm_tmp_folder + name + ".rom", "orixlibs/orixsdk/usr/lib/orix-sdk.lib"]
            resultat = subprocess.run(cmd_ld65 + LD_FLAGS + arg_ld65, check=True, capture_output=False, text=True)

        else:
            arg_ld65 = ['-tnone' , bpm_tmp_folder + name + ".ld65", "-o", bpm_tmp_folder + name + ".rom"]
            resultat = subprocess.run(cmd_ld65 + arg_ld65, check=True, capture_output=False, text=True)

        shutil.copy(bpm_tmp_folder + name + ".rom", rom_path + name + ".rom")

    if codetype == "bin":

        if not os.path.exists(f"{build_folder}/bin/"):
            os.makedirs(f"{build_folder}/bin/", mode=0o755, exist_ok=True)

        if not os.path.exists(reloc_bin_path):
            print("Error. Can not build without Orix sdk. Orix sdk not installed. orix sdk plugins is required to build binaries (see 'bpm plugins')")
            return 1

        err = generate_lib_for_bin(name, arg_include, arg_include_asm)
        if err == -1:
            print("Error during lib generation")
            return 1

        force_build = False
        # Many files are compile, we need to build binary
        if err > 0:
            force_build = True

        list_src_file_to_build = []
        list_binary_file_to_build = []


        file_to_compile_c = repertoire + name + ".c"
        file_to_compile_s = repertoire + name + ".s"


        list_src_file_to_build.append(file_to_compile_c)
        list_src_file_to_build.append(file_to_compile_s)

        list_binary_file_to_build.append(name)
        list_binary_file_to_build.append(name)

        # Get all files in bin section and add them to build list
        if "bin" in data:
            for bin_entry in data["bin"]:
                binname = bin_entry["name"]
                key = f"path_{binname}"

                list_src_file_to_build.append(bin_entry[key])
                list_binary_file_to_build.append(binname)

        for src_file, binname_to_build in zip(list_src_file_to_build, list_binary_file_to_build):

            nom_sans_extension = binname_to_build
            if os.path.exists(src_file):
                if src_file.endswith(".c"):
                    try:
                        build_without_cl65_c_files(arg_include_c, arg_include_asm, arg_ld_libs, src_file, bpm_tmp_folder, name, force_build, binname_to_build)
                        nom_sans_extension = convert_binary_name_to_seven_chars(nom_sans_extension)
                        resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + nom_sans_extension, '-2', bpm_tmp_folder + f'{binname_to_build}_2048', bpm_tmp_folder + f'{binname_to_build}_2304'], check=True, capture_output=False, text=True)
                        shutil.copy(bpm_tmp_folder + nom_sans_extension, f"{build_folder}/bin/" + nom_sans_extension)
                        print("Built : " + f"{build_folder}/bin/" + nom_sans_extension)
                    except subprocess.CalledProcessError as e:
                        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                        return 1


                if src_file.endswith(".s"):
                    try:
                        print(f"Build : {src_file}")
                        bin_cl65 = ['cl65']
                        arg_cl65 = ['-ttelestrat', src_file, "-o", bpm_tmp_folder + '2048', '--start-addr',  '2048',  "--include-dir", "src/include", f"{name}.lib"]
                        arg_cl65_2304 = ['-ttelestrat', src_file, "-o", bpm_tmp_folder + '2304', '--start-addr',  '2304',  "--include-dir", "src/include", f"{name}.lib"]
                        resultat = subprocess.run(bin_cl65 + arg_include_asm + arg_include + arg_cl65 + arg_ld_libs, check=True, capture_output=False, text=True)
                        resultat = subprocess.run(bin_cl65 + arg_include_asm + arg_include + arg_cl65_2304 + arg_ld_libs, check=True, capture_output=False, text=True)
                        resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + nom_sans_extension, '-2', bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                        shutil.copy(bpm_tmp_folder + nom_sans_extension, f"{build_folder}/bin/" + nom_sans_extension)
                        print("Built : " + f"{build_folder}/bin/" + nom_sans_extension)
                        return 0
                    except subprocess.CalledProcessError as e:
                        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
        return 0
        #print(f"Main file not found : {file_to_compile_c} or {file_to_compile_s}")

    #########################################################
    # Building lib
    #########################################################

    if codetype == "lib":
        print(f"Generate {name}.lib")
        rebuild_so = False
        generate_bin_files_section = False # If we modify lib, we need to build binary files from bin section in bpm.tml

        if 'srcfolders' in data:
            # Ajouter la section "srcfolders" avec une valeur par défaut (par exemple, une liste vide)
            for key, value in data['srcfolders'].items():
                compile(name, arg_include, key)

        # If someone erased lib; force rebuild
        if not os.path.exists(f"{name}.lib"):
            generate_all = True

        # if not os.path.exists(f"{build_folder}/usr/lib/{name}/{version}/llo/"):
        #     os.makedirs(f"{build_folder}/usr/lib/{name}/{version}/llo/", mode=0o755, exist_ok=True)

        # # Do we manage dynamic lib ?
        # if not os.path.exists(f"{build_folder}/usr/share/{name}/{version}/" + dynamic_lib_name_module):
        #     generate_all = True

        # if not os.path.exists(f"{build_folder}/usr/lib/{name}/{version}/llo/" + name + ".lib"):
        #     generate_all = True

        # if not os.path.exists(f"bpmtmp/{name}.a"):
        #     generate_all = True

        # if not os.path.exists(f"src/dynamic_lib/{name}_so.s"):
        #     generate_all = True
        #     rebuild_so = True
        #     # Create an empty file
        #     with open(f"src/dynamic_lib/{name}_so.s", 'w') as file:
        #         file.write("; stub\n")

        for fichier in fichiers_s:
            nom_sans_extension = os.path.splitext(fichier)[0]
            try:
                generate = False
                fichier_source = repertoire + fichier
                fichier_dest_o = bpm_tmp_folder + nom_sans_extension + ".o"

                generate = check_src_with_target_file(fichier_source, fichier_dest_o)
                if generate == True or generate_all == True:
                    print("Building " + repertoire + fichier)
                    bin_ca65 = ['ca65']
                    arg_ca65 = ['-ttelestrat', fichier_source, "-o", fichier_dest_o, "--include-dir", "src/include"]

                    print(f"Here : {arg_include_asm}")
                    arg_include_ca65 = []
                    arg_include_asm_tab = arg_include_asm.strip().split(' ')

                    for index, valeur in enumerate(arg_include_asm_tab):
                        arg_include_ca65.append('-I')
                        arg_include_ca65.append(arg_include_asm_tab[index])

                    #arg_include_ca65 = [arg_include]
                    resultat = subprocess.run(bin_ca65 + arg_include_ca65 + arg_ca65, check=True, capture_output=True, text=True)
                    rebuild_so = True

            except subprocess.CalledProcessError as e:
                print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                return 1

            if generate == True or generate_all == True:
                print("Adding " + bpm_tmp_folder + nom_sans_extension + ".o to " + name + ".lib")
                resultat = subprocess.run(['ar65', 'r', name + ".lib", fichier_dest_o], check=True, capture_output=False, text=True)
                generate_bin_files_section = True
                # if fichier.startswith('_'):
                #     # Add C proto into "llo"
                #     print("[Dynamic-lib] Adding " + bpm_tmp_folder + nom_sans_extension + ".o to llo/" + name + ".lib")
                #     resultat = subprocess.run(['ar65', 'r', f"{build_folder}/usr/lib/{name}/{version}/llo/" + name + ".lib", fichier_dest_o], check=True, capture_output=False, text=True)

        ##############################################
        #  Generate lib link object (.llo)
        ##############################################
        # print("Building " + name + ".lib (for llo folder)")
        # resultat = subprocess.run(['ca65', '-ttelestrat', f"src/dynamic_lib/{name}.s", "-o", f"bpmtmp/{name}.o"], check=True, capture_output=False, text=True)
        # resultat = subprocess.run(['ar65', 'r', f"{build_folder}/usr/lib/{name}/{version}/llo/{name}.lib", f"bpmtmp/{name}.o"], check=True, capture_output=False, text=True)

        ##############################################
        #  Generate dynamic lib (.so)
        ##############################################
        # if rebuild_so == True:
        #     try:
        #         # Supprimer le fichier
        #         os.remove(f"src/dynamic_lib/{name}_so.s")
        #         with open(f"src/dynamic_lib/{name}_so.s", 'w') as file:
        #             file.write("; stub\n")

        #     except Exception as e:
        #         print(f"Error : {e}")

        #     for fichier in fichiers_s:
        #         if not fichier.startswith('_'):
        #             with open(f"src/dynamic_lib/{name}_so.s", 'a') as fichier_so:
        #                 parties = fichier.rsplit('.', 1)
        #                 proc = parties[0]
        #                 fichier_so.write(f".import {proc}\n jmp {proc}\n")

        #     resultat = subprocess.run(['cl65', '-tnone', f"src/dynamic_lib/{name}_so.s", name + ".lib" , "-o", f"bpmtmp/" + name + "_2048.lso", '--start-addr',  '2048'], check=True, capture_output=False, text=True)
        #     resultat = subprocess.run(['cl65', '-tnone', f"src/dynamic_lib/{name}_so.s", name + ".lib" , "-o", f"bpmtmp/" + name + "_2304.lso", '--start-addr',  '2304'], check=True, capture_output=False, text=True)

        #     # VErsion header 128 equal to so lib
        #     header = bytearray([0x01, 0x00, ord('o'), ord('r'), ord('i'), # Signature
        #                     128 + 0x00,                # header version : Version header b7=1 is  so (dynamic lib)
        #                     0x00,                      # CPU
        #                     0x00, 0x00,                # SIZE_BITFIELD
        #                     0x00,                      # Reserved
        #                     0x00,                      # Reserved
        #                     0x00,                      # Reserved
        #                     0x00, 0x00,                # OFFSET_BITFIELD
        #                     0x00, 0x00,                # start_adress
        #                     0x00, 0x00,                # endofmemory
        #                     0x00, 0x00,                # start_adress
        #                     ])

            # Add header for first file
            # Compute startaddr and loading address
            # byte_low = 2048 & 0xFF
            # byte_high = (2048 >> 8) & 0xFF

            # header[14] = byte_low
            # header[15] = byte_high

            # header[18] = byte_low
            # header[19] = byte_high

            # # Lire le contenu existant du fichier
            # with open(f"bpmtmp/" + name + "_2048.lso", 'rb') as fichier:
            #     contenu_existant = fichier.read()
            # val = len(contenu_existant)
            # val = val + 2048 - 1
            # # Get size
            # size_byte_low = val & 0xFF
            # size_byte_high = (val >> 8) & 0xFF
            # # Store size
            # header[16] = size_byte_low
            # header[17] = size_byte_high

            # # Écrire l'en-tête suivi du contenu existant dans le fichier
            # with open(f"bpmtmp/" + name + "_2048.so", 'wb') as fichier:
            #     fichier.write(header + contenu_existant)

            # # Manage second file

            # byte_low = 2304 & 0xFF
            # byte_high = (2304 >> 8) & 0xFF

            # header[14] = byte_low
            # header[15] = byte_high

            # header[18] = byte_low
            # header[19] = byte_high

            # # Lire le contenu existant du fichier
            # with open(f"bpmtmp/" + name + "_2304.lso", 'rb') as fichier:
            #     contenu_existant = fichier.read()
            # val = len(contenu_existant)
            # val = val + 2304 - 1
            # size_byte_low = val & 0xFF
            # size_byte_high = (val >> 8) & 0xFF

            # header[16] = size_byte_low
            # header[17] = size_byte_high

            # # Écrire l'en-tête suivi du contenu existant dans le fichier
            # with open(f"bpmtmp/" + name + "_2304.so", 'wb') as fichier:
            #     fichier.write(header + contenu_existant)

            # # Generate final .so
            # if dynamic_lib_name_module != "":
            #     resultat = subprocess.run(["python3" , reloc_bin_path, "--verbose",  "-o", f"{build_folder}/usr/share/{name}/{version}/" + dynamic_lib_name_module, '-2' ,f"bpmtmp/" + name + "_2048.so", f"bpmtmp/" + name + "_2304.so"], check=True, capture_output=False, text=True)

        path_file_lib = f"{build_folder}/usr/share/{name}/{version}"
        if not os.path.exists(path_file_lib):
            os.makedirs(path_file_lib, mode=0o755, exist_ok=True)

        if os.path.exists(name + ".lib"):
            shutil.copy(name + ".lib", f"{path_file_lib}/{name}.lib")
            print("Build completed")

        else:
            print("No build done")

    # Build all binary in [[bin]] section
    file_path = "bpm.tml"
    with open(file_path, "r") as file:
        data = toml.load(file)

    # Afficher tous les noms dans [[bin]]
    if "bin" in data:
        if not os.path.exists(f"{build_folder}/bin/"):
            os.makedirs(f"{build_folder}/bin/", mode=0o755, exist_ok=True)

        for bin_entry in data["bin"]:
            if "name" in bin_entry:
                print(f"Building binary : {bin_entry['name']}")
                binname = bin_entry["name"]
                key = f"path_{binname}"
                file_to_compile_c = bin_entry[key]
                #print(file_to_compile_c)
                if os.path.exists(file_to_compile_c):
                    try:
                        build_without_cl65_c_files(arg_include, arg_include_asm, arg_ld_libs, file_to_compile_c, bpm_tmp_folder, name, generate_bin_files_section, name)
                        # Perform reloc_bin
                        resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + binname, '-2' ,bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                        shutil.copy(bpm_tmp_folder + binname, f"{build_folder}/bin/" + bin_entry["name"])
                        print("Built : " + f"{build_folder}/bin/" + bin_entry["name"])
                    except subprocess.CalledProcessError as e:
                        print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
                    return 0
                else:
                    print(f"{file_to_compile_c} not found, can not build {binname} binary")

def usage():
    print(f"Orix build and package manager ({VERSION_BPM})\n")
    print("Documentation : https://orix-software.github.io/bpm/\n")

    print("Usage : bpm [OPTIONS] [COMMAND]\n")
    print("\033[1;32mOptions:\033[0m")
    print("    \033[1;36m-V\033[0m                     Displays version")
    print("    \033[1;36m--disable-check-update\033[0m Disables check for new version")
    print("    \033[1;36m--force-update\033[0m         Force bpm update")
    print("    \033[1;36m--replace-for-new-project\033[0m         available with --force-update option, it will install plugin for new project")


    print("")
    print("\033[1;32mCommands:\033[0m")
    print("    \033[1;36mnew\033[0m             Init a new orix package")
#    print("    \033[1;36minit\033[0m            Init an orix package in an existing directory")
    print("    \033[1;36mbuild\033[0m           Build")
    print("    \033[1;36mdoc\033[0m             Build docs")
    print("    \033[1;36mrun\033[0m             Run")
    print("    \033[1;36mlist\033[0m            List packages")
    print("    \033[1;36madd         \033[0m    Add dependencies to a manifest file")
    #print("    \033[1;36mdynamiclib  \033[0m    Define a dynamic lib from dependency list")
    print("    \033[1;36mremove      \033[0m    Remove dependencies from a manifest file")
    print("    \033[1;36minstall     \033[0m    Install all dependencies from a manifest file")
    print("    \033[1;36msearch      \033[0m    Search package")
    print("    \033[1;36mpublish     \033[0m    Publish package")
    print("    \033[1;36munpublish   \033[0m    Unpublish package")
    print("    \033[1;36mplugins     \033[0m    Manage plugins")
    print("    \033[1;36mconfig      \033[0m    Manage config")
    print("    \033[1;36mpackage     \033[0m    Manage package")
    print("    \033[1;36maddsrc      \033[0m    Add src folder to build manifest file")

def plugins_detect(mode):
    force_version_for_new_project = 0

    for cle, valeur in plugins_description.items():
        if mode == "display":
            print(f"\033[1;36m{cle}\033[0m: {valeur}", end="")

        if mode == "update_and_force_new_version_for_next_project":
            force_version_for_new_project = 1

        if cle == "md2hlp":
            file_path = os.path.join(folder_path_md2hlp , "md2hlp-master/")
            if not os.path.exists(file_path):
                install_md2hlp()
                if mode == "display":
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    plugins_installed['md2hlp'] = False
            else:
                if mode == "display":
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['md2hlp'] = True

        if cle == "orixsdk":
            folder_path_orixsdk = os.path.expanduser("~/.bpm/plugins/orixsdk/")
            file_path = os.path.join(folder_path_orixsdk , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("orixsdk", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['orixsdk'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_orixsdk) if os.path.isdir(os.path.join(folder_path_orixsdk, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['orixsdk'] = True

        if cle == "asm_bin_tpl":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/asm_bin_tpl/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("asm_bin_tpl", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['asm_bin_tpl'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['asm_bin_tpl'] = True

        if cle == "asm_rom_tpl":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/asm_rom_tpl/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("asm_rom_tpl", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['asm_rom_tpl'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['asm_rom_tpl'] = True

        if cle == "github_action":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/github_action/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("github_action", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['github_action'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['github_action'] = True

        if cle == "generatedoc":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/plugins/generatedoc/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                val = install_tpl_from_github("generatedoc", force_version_for_new_project)
                if val != 1:
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['asm_romgeneratedoc_tpl'] = False
            else:
                plugin_version = [d for d in os.listdir(folder_path_asm_bin) if os.path.isdir(os.path.join(folder_path_asm_bin, d))]
                if mode == "display":
                    print(f" \033[1;32m (Available versions : {plugin_version}) [Installed]\033[0m")
                else:
                    plugins_installed['generatedoc'] = True

def plugins(args):
    if len(args) == 3:
        if args[2] == "-h":
            print("Manage plugins\n")
            print("Usage : bpm plugins [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36minstall\033[0m             install plugin")
            return 0

    if len(args) == 4:
        if args[3] == "-h":
            print("Manage plugins\n")
            print("Usage : bpm plugins install [plugin_name] [--replace-for-new-project]\n")
            print("\033[1;32m--replace-for-new-project if we found a newer plugin version, update main bpm config to use this plugin version in the next projects\033[0m")
            print("\033[1;32mAvailables plugins:\033[0m")

            for cle, valeur in plugins_description.items():
                print(f"\033[1;36m{cle}\033[0m: {valeur}")
            return 0


    replace_for_new_project = 0
    if len(sys.argv) >= 3:
        if sys.argv[2] == "install":
            if len(sys.argv) == 5:
                if sys.argv[4] == "--replace-for-new-project":
                    replace_for_new_project = 1
            if len(sys.argv) >= 4:
                if sys.argv[3] == "orixsdk":
                    install_tpl_from_github('orixsdk', replace_for_new_project)
                elif sys.argv[3] == "asm_bin_tpl":
                    install_tpl_from_github('asm_bin_tpl', replace_for_new_project)
                elif sys.argv[3] == "md2hlp":
                    install_md2hlp()
                elif sys.argv[3] == "asm_rom_tpl":
                    install_tpl_from_github('asm_rom_tpl', replace_for_new_project)
                elif sys.argv[3] == "github_action":
                    install_tpl_from_github('github_action', replace_for_new_project)
                elif sys.argv[3] == "generatedoc":
                    install_tpl_from_github('generatedoc', replace_for_new_project)
                else:
                    print("Unknown plugin")
            else:
                print("Missing parameter")
        elif sys.argv[2] == "update":
            if len(sys.argv) == 5:
                if sys.argv[4] == "--replace-for-new-project":
                    replace_for_new_project = 1

            install_tpl_from_github('orixsdk', replace_for_new_project)
            install_tpl_from_github('asm_bin_tpl', replace_for_new_project)
            install_md2hlp()
            install_tpl_from_github('asm_rom_tpl', replace_for_new_project)
            install_tpl_from_github('github_action', replace_for_new_project)
            install_tpl_from_github('generatedoc', replace_for_new_project)
        else:
            print("Unknown parameter")

    if len(sys.argv) == 2:
        print("Use 'bpm plugins -h' for 'plugins' help")
        plugins_detect("display")


def modify_local_toml_key(toml_file, new_name, section, property):
    # Lire le fichier TOML
    with open(toml_file, 'r') as fichier:
        contenu = toml.load(fichier)

    # Vérifier si la section section existe et changer la valeur de 'name'
    contenu[section][property] = new_name

    # Réécrire le fichier avec la nouvelle valeur
    with open(toml_file, 'w') as fichier:
        toml.dump(contenu, fichier)

    print(f"'{property}' updated with '{new_name}'.")

def print_frame(str_to_display, sep):
    print(symbs[1], end = '')
    str_length = len(str_to_display)
    for i in range( str_length + 2):
        print(symbs[5], end = '')
    print(symbs[7])
    print(symbs[8] + ' ', end = '')
    print(str_to_display + ' ' + symbs[8])
    print(symbs[9], end = '')
    for i in range( str_length + 2):
        print(symbs[5], end = '')
    print(symbs[10])

def manage_config(args):
    valid_parameters_main = ['oricutron_path' , 'oricutron_replace_autoboot_run' , 'default_rom_oricutron_for_code']
    valid_parameters_main_desc = ['                  Set Oricutron path for main (general behavior), value must be path of Oricutron binary with filename binary in the path',
                                  '  Set False or True. False will not modify /etc/autoboot in Oricutron',
                                  '  Default rom when code type is rom : the .rom will be inserted into this slot'
                                  ]

    valid_parameters_main_verify = ['path', 'boolean', 'string']

    valid_parameters_project = ['name', 'version', 'codetype', 'oricutron_replace_autoboot_run', 'oricutron_path', 'default_rom_oricutron_for_code', 'orix_run_pre_script', 'md2hlp']
    valid_parameters_project_desc = ['                            Name of the project',
                                     '                         Version of the project',
                                     '                        Code type of the project (lib is a library, bin a command line [lib|bin])',
                                     '  Set False or True. False will not modify /etc/autoboot in Oricutron when bpm run is executed',
                                     '                  Set Oricutron path for current project',
                                     '  Default rom when code type is rom : the .rom will be inserted into this slot',
                                     '             Pre submit script : will be added before project command',
                                     '                        Activate md2hlp : enable set to yer, disabled set to no'
                                     ]

    valid_parameters_project_verify = ['string', 'string', 'values=bin,lib' ,'boolean', 'string', 'string', 'string', 'string']

    # bpm set main -h
    if len(args) == 5:
        if args[4] == '-h' and args[2] == 'set' and args[3] == 'main':
            # bpm set main -h
            print("Set main config parameters\n")
            print("Usage : bpm config set main parameter value\n")
            print("\033[1;32mParameters\033[0m")
            i = 0
            for key in valid_parameters_main:
                print(f"    \033[1;36m{key}\033[0m{valid_parameters_main_desc[i]}")
                i = i + 1
            return 0

        if args[4] == '-h' and args[2] == 'add' and args[3] == 'project':
            print("Manage config\n")
            print("Usage : bpm config add project\n")
            print("\033[1;32mCommands\033[0m")
            print("    \033[1;36mbinary\033[0m             set a binary to build")
            print("    \033[1;36mdynamic-lib\033[0m        set a dynamic lib to build (not done yet)")
            #print("binary binarybin source path")
            i = 0
            return 0

        if args[4] == '-h' and args[2] == 'set' and args[3] == 'project':
            print("Manage config\n")
            print("Usage : bpm config set project parameter value\n")
            print("\033[1;32mParameters\033[0m")
            i = 0
            for key in valid_parameters_project:
                print(f"    \033[1;36m{key}\033[0m{valid_parameters_project_desc[i]}")
                i = i + 1
            return 0


    if len(args) == 4:
        # bpm set -h
        if args[3] == '-h' and args[2] == 'set':
            print("Manage config\n")
            print("Usage : bpm config set [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mmain\033[0m             set value for 'main' config (use -h after set for 'main' help)")
            print("    \033[1;36mproject\033[0m          set value for 'project' config (use -h after set for 'project' help)")
            return 0

        # bpm add -h
        if args[3] == '-h' and args[2] == 'add':
            print("Manage config\n")
            print("Usage : bpm config set [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mproject\033[0m          set a add value for 'project'")
            return 0

    if len(args) == 3:
        if args[2] == '-h' or args[2] == 'help':
            print("Manage config\n")
            print("Usage : bpm config [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mset\033[0m             set value for main config or project config (use -h after set for 'set' help)")
            print("    \033[1;36madd\033[0m             add a binary into project file")
            return 0

        if args[2] == 'add':
            print('Missing parameter')
            print("Manage config\n")
            print("Usage : bpm config [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mset\033[0m             set value for main config or project config (use -h after set for 'set' help)")
            print("    \033[1;36madd\033[0m             add a binary into project file")
            return 0


    if len(args) == 5:

        #bpm config add project binary curl tests/curl.c arg1
        if args[4] not in valid_parameters_project and args[3] == 'project':
            print("'" + args[4] + "' is not a parameter allowed for '" + args[3] + "'")
            return 1

        if args[4] not in valid_parameters_main  and args[3] == 'main':
            print("'" + args[4] + "' is not a parameter allowed for '" + args[3] + "'")
            return 1

        if args[2] == 'set' and args[3] == 'main':
            print("Missing value for parameter '" + args[4] + "'")
            return 1

        if args[2] == 'set' and args[3] == 'project':
            print("Missing value for parameter '" + args[4] + "'")
            return 1

        if args[2] == 'add' and args[3] == 'project' and args[4] == 'dynamic-lib' and args[5] == '-h':
            print("Manage config : add a dynamic-lib to project\n")
            print("Usage : bpm config add project dynamic-lib [targetfilename]\n")
            print("targetfilename is for example 'libcurl.so'")
            return 0

    if len(args) == 6:

        if args[2] == 'add' and args[3] == 'project' and args[4] == 'dynamic-lib':
            #bpm config add project binary binarybin path
            with open("bpm.tml", "r") as file:
                data = toml.load(file)

            data["package"]["dynamic-lib-src-path-module"] = args[7]
            data["package"]["dynamic-lib-name-module"] = args[8]

            # Enregistrer les modifications dans le fichier
            with open("bpm.tml", "w") as file:
                toml.dump(data, file)
            print("dynamic-lib added")
            return 0


    if len(args) > 6:
        # Add binary
        # bpm config add project binary curl tests/curl.c arg1
        if args[2] == 'add' and args[3] == 'project' and args[4] == 'binary':
            #bpm config add project binary binarybin path
            with open("bpm.tml", "r") as file:
                data = toml.load(file)
            # Ajouter la section [[bin]] avec les valeurs souhaitées
            if len(args) == 8:
                bin_section = {"name": args[5], "path_"+ args[5]: args[6], "extra_args_"+ args[5]: args[7]}
            else:
                bin_section = {"name": args[5], "path_"+ args[5]: args[6]}
            if "bin" not in data:
                data["bin"] = []
            data["bin"].append(bin_section)

            # Enregistrer les modifications dans le fichier
            with open("bpm.tml", "w") as file:
                toml.dump(data, file)
            print("Binary added")
            return 0

    if len(args) == 6:

        if args[2] == 'add' and args[3] == 'project' and args[4] == 'binary' and args[5] == '-h':
            print("Manage config : add a binary to project\n")
            print("Usage : bpm config add project binary [name of the binary] [path_of_the_source_code]\n")
            return 0

        if args[2] == 'set' and args[3] == 'main':
            if args[4] in valid_parameters_main:
                verify_position = valid_parameters_main.index(args[4])
                if valid_parameters_main_verify[verify_position] == 'boolean':
                    if args[5] != 'True' and args[5] != 'False':
                        print(f"Error {args[4]} requires True or False")
                        return

                home_directory = os.path.expanduser('~')

                new_directory = f"{user_folder}/bpm"
                # Chemin complet du nouveau répertoire
                directory_path = home_directory + "/" + new_directory

                print("Updating 'main' config value ...")
                modify_local_toml_key(directory_path, args[5], 'main', args[4])
                return
            else:
                print(f"Unknown key '{args[4]}' for 'main' config")
                return

        if args[2] == 'set' and args[3] == 'project':
            verify_position = valid_parameters_project.index(args[4])
            if args[4] in valid_parameters_project:
                if valid_parameters_project_verify[verify_position] == 'boolean':
                    if args[5] != 'True' and args[5] != 'False':
                        print(f"Error {args[4]} requires True or False")
                        return
                print("Updating 'project' config value ...")
                modify_local_toml_key('bpm.tml', args[5], 'package', args[4])
                return
            else:
                print(f"Unknown key '{args[4]}' for 'project' config")
                return

    if len(sys.argv) == 2:
        if not os.path.exists("bpm.tml"):
            print("bpm.tml does not exist. Initialize first")
            return 1

        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/bpm"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory
        print_frame("Main config", "")

        try:
            with open(directory_path, 'r') as fichier:
                contenu = fichier.read()
                print(contenu)
        except FileNotFoundError:
            print(f"Le fichier '{directory_path}' n'a pas été trouvé.")
        except Exception as e:
            print(f"Une erreur est survenue : {e}")

    print_frame("Project config", "")
    with open(toml_file, 'r') as file:
        data = toml.load(file)

    if "package" in data:
        package = data["package"]
        for key, value in package.items():
            print(f"{key}={value}")


def publish(filename: str, args, mode):
    repo = "alpha"
    if len(args) == 3:
        if mode == "publish":
            if args[2] == "-h":
                print("Manage publish\n")
                print("Usage : bpm publish [OPTIONS]\n")
                print("\033[1;32mOptions:\033[0m")
                print("    \033[1;36m--alpha\033[0m          Publish in alpha repo (default)")
                print("    \033[1;36m--official\033[0m       Publish in official repo")
                print("    \033[1;36m--personnal\033[0m      Publish in personnal (stored in login associated to the the BPM_PUBLISH_KEY) repo")
                return 0
        elif mode == "unpublish":
            if args[2] == "-h":
                print("Unpublish a pacjage\n")
                print("Usage : bpm unpublish [OPTIONS]\n")
                print("\033[1;32mOptions:\033[0m")
                print("    \033[1;36m--alpha\033[0m          Unpublish from alpha repo (default)")
                print("    \033[1;36m--official\033[0m       Unpublish from official repo")
                print("    \033[1;36m--personnal\033[0m      Unpublish from personnal (stored in login associated to the the BPM_PUBLISH_KEY) repo")
                return 0
        if args[2] == "--alpha":
            repo = "alpha"
        elif args[2] == "--official":
            repo = "official"
        elif args[2] == "--personnal":
            repo = "personnal"
        else:
            print("Unknown parameter")
            return 1

    conf = read_local_config_file()
    publish_key = os.getenv('BPM_PUBLISH_KEY')
    name = conf["package"]["name"]
    version = conf["package"]["version"]
    cpu = conf["package"]["cpu"]
    codetype = conf["package"]["codetype"]
    description = conf["package"]["description"]
    documentation = conf["package"]["documentation"] if "documentation" in conf["package"] else ""

    if "documentation" != "":
        documentation = urllib.parse.quote_plus(documentation)

    if publish_key is None:
        print("BPM_PUBLISH_KEY is not defined in order to publish on repo.orix.oric.org. To get one, send an email to jede[at]oric[dot]org")
        return 1

    if mode == "publish":
        action = "add"

    if mode == "unpublish":
        action = "delete"

    # # adding etc bpm.tml build/etc/bpm/
    # if not os.path.exists(f'build/etc/{name}/{version}'):
    #     os.makedirs(f'build/etc/{name}/{version}', mode=0o755, exist_ok=True)
    # shutil.copy('bpm.tml', destination_dir)

    if mode == "publish":
        encoded_description = urllib.parse.quote(description)
        url = f"http://api.orix.oric.org/v1/libtgz?cpu={cpu}&repo={repo}&version={version}&name={name}&codetype={codetype}&action={action}&description={encoded_description}&documentation={documentation}&key=" + publish_key

        with open(filename, 'rb') as fichier:
            fichiers = {filename: fichier}  # Préparer le fichier pour l'envoi

            # Effectuer la requête POST
            response = requests.post(url, files=fichiers)
            print(response.content)
            # Vérifier si la requête a réussi
            if response.status_code == 200:
                print("Success!")
                return 0
            else:
                print(f"Failed. Error code : {response.status_code}")
                print(f"API response: {response.text}")
                return 1

    if mode == "unpublish":
        # Effectuer la requête POST
        url = f"http://api.orix.oric.org/v1/libtgz?cpu={cpu}&repo={repo}&version={version}&name={name}&action={action}&codetype={codetype}&key=" + publish_key
        response = requests.post(url)
        print(response.content)
        # Vérifier si la requête a réussi
        if response.status_code == 200:
            print("Success!")
            return 0
        else:
            print(f"Failed. Error code : {response.status_code}")
            print(f"API response: {response.text}")
            return 1

def install_tpl_from_github(plugin_name, replace_for_next_version):
    # Chatgpt:
    # Si le folder ~/.bpm/tpl/asm_bin_tpl/ n'existe pas, telecharge https://github.com/assinie/new-project/archive/refs/heads/main.zip, dezippe le dans ~/.bpm/tpl/
    # Définir le chemin du dossier asm_bin_tpl
    answer = ""
    folder_path = os.path.expanduser(f"~/.bpm/plugins/{plugin_name}/")
    # Get version
    response = requests.get(plugins_url_version[plugin_name])

    if response.status_code == 200:
        plugin_version = response.text
        plugin_version = plugin_version.replace("\n", "")

    else:
        print(f"Impossible to download VERSION definition : {plugins_url_version[plugin_name]} {response.status_code}")
        return 1

    print(f"\nInstalling plugin : {plugin_name} Version : {plugin_version}")

    path_plugin = folder_path + plugin_version

    # Vérifier si le dossier existe
    if not os.path.exists(path_plugin):

        # Créer le dossier parent ~/.bpm/{plugin_name}/{plugin_version} s'il n'existe pas
        parent_folder = os.path.dirname(path_plugin + "/" + plugin_version)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        # Télécharger l'archive depuis GitHub

        url_for_plugin = plugins_url[plugin_name].replace("#VERSION#", plugin_version)
        response = requests.get(url_for_plugin)


        # Vérifier si le téléchargement est réussi
        if response.status_code == 200:
            # Décompresser l'archive
            if url_for_plugin.endswith(".zip"):
                with zipfile.ZipFile(BytesIO(response.content)) as z:
                    z.extractall(parent_folder)  # Décompresser dans ~/.bpm/tpl/
            else:
                destfile = parent_folder + "/" + url_for_plugin.split("/")[-1]
                with open(destfile, "wb") as file:
                    file.write(response.content)

            if replace_for_next_version == 0:
                answer = input(f"Set this plugin version '{plugin_version}' for next projects (this plugin version will be set when 'bpm new' is sent)? (N/y)")

            if answer == 'y' or answer == 'Y' or replace_for_next_version == 1:
                main_config_path = os.path.expanduser(f"~/.bpm/bpm")
                modify_local_toml_key(main_config_path, plugin_version, 'main', plugins_main_property_name[plugin_name])
            print("Installed")

        else:
            print("Erreur lors du téléchargement. Code de statut:", response.status_code)
            return 1
    else:
        print(f"Already installed : {plugin_name}")


def install_md2hlp():
    # Chatgpt:
    # Si le folder ~/.bpm/md2hlp/ n'existe pas, telecharge https://github.com/assinie/md2hlp/archive/refs/heads/master.zip, dezippe le dans ~/.bpm/md2hlp/
    print("Installing md2hlp")

    # Créer le dossier s'il n'existe pas
    if not os.path.exists(folder_path_md2hlp):
        os.makedirs(folder_path_md2hlp)

    # Télécharger l'archive depuis GitHub
    url = "https://github.com/assinie/md2hlp/archive/refs/heads/master.zip"
    response = requests.get(url)

    # Vérifier si le téléchargement est réussi
    if response.status_code == 200:

        # Décompresser l'archive
        with zipfile.ZipFile(BytesIO(response.content)) as z:
            z.extractall(folder_path_md2hlp )

        print("md2hlp installed")
    else:
        print("Download error. Error code :", response.status_code)

def build_doc(toml_file):
    md2hlp_generate = False
    generatedoc_generate = False
    docs_folder = "docs/"


    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 0

    data = read_local_config_file()

    # Test md2hlp
    # Chatgpt :
    plugins_detect("detect")
    if not plugins_installed['md2hlp']:
        install_md2hlp()

    if not plugins_installed['generatedoc']:
        install_tpl_from_github("generatedoc", 0)
    plugins_detect("detect")

    if not plugins_installed['generatedoc']:
        print('generatedoc not detected, skipping generatedoc generation')
    else:
        generatedoc_generate = True

    if not plugins_installed['md2hlp']:
        print('md2hlp not detected, skipping md2hlp generation')
    else:
        md2hlp_generate = True

    if "package" in data:
        package = data["package"]
        version =  data["package"]["version"]

        if "md2hlp" in package:
            if package["md2hlp"] == 'no':
                md2hlp_generate = False
            else:
                md2hlp_generate = True

        if "docsfolder" in package:
            docs_folder = package["docsfolder"]

        if "default_generatedoc_version" in package:
            default_generatedoc_version = package["default_generatedoc_version"]
        else:
            main_config_data = read_main_config_file()
            if "main" in main_config_data:
                if "default_generatedoc_version" in main_config_data["main"]:
                    default_generatedoc_version = main_config_data["main"]["default_generatedoc_version"]
                else:
                    generatedoc_generate = False
                    print("Generate doc default version not found in main config.")
            else:
                generatedoc_generate = False
                print("Missing main section in main config.")
    else:
        print("Error missing package section in bpm.tml")

    if md2hlp_generate:
        if not os.path.exists("src/md2hlp.cfg"):
            home_directory = os.path.expanduser('~')
            directory_path = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.cfg"
            shutil.copy(directory_path, f"{docs_folder}/")

        if not os.path.exists(f"{build_folder}/usr/share/man/"):
            os.makedirs(f"{build_folder}/usr/share/man/", exist_ok=True)

        home_directory = os.path.expanduser('~')
        md2hlp_cmd = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.py3"

        for fichier in os.listdir(f"{docs_folder}"):
            # Vérifier si le fichier a l'extension .md
            generate = False
            if fichier.endswith(".md"):
                my_file = fichier.replace('.md', ".hlp")
                generate = check_src_with_target_file(f"{docs_folder}/{fichier}", f"{build_folder}/usr/share/man/{my_file}")
                if generate == True and os.path.getsize(f"{docs_folder}{fichier}") != 0:
                    print(f"[md2hlp] Generating {fichier} to {build_folder}/usr/share/man/{my_file}")
                    resultat = subprocess.run(['python3', md2hlp_cmd, '--config', f'{docs_folder}/md2hlp.cfg',  '--file', f"{docs_folder}/{fichier}", "--output", f"{build_folder}/usr/share/man/{my_file}"] , check=True, capture_output=False, text=True)

    if generatedoc_generate:
        # if not os.path.exists("src/md2hlp.cfg"):
        #     home_directory = os.path.expanduser('~')
        #     directory_path = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.cfg"
        #     shutil.copy(directory_path, "docs/")

        # if not os.path.exists("build/usr/share/man/"):
        #     os.makedirs("build/usr/share/man/", exist_ok=True)

        home_directory = os.path.expanduser('~')
        generatedoc_cmd_assembly = home_directory + f"/.bpm/plugins/generatedoc/{default_generatedoc_version}/generatedoc-main/src/ca65todoc.py"
        generatedoc_cmd_c = home_directory + f"/.bpm/plugins/generatedoc/{default_generatedoc_version}/generatedoc-main/src/ca65todoc_c_proto.py"

        if not os.path.exists(f"{docs_folder}/{version}/"):
            os.makedirs(f"{docs_folder}/{version}/")

        for fichier in os.listdir("src"):
            # Vérifier si le fichier a l'extension .md
            generate = False
            if fichier.endswith(".s"):
                my_file = fichier.replace('.s', ".md")
                generate = check_src_with_target_file(f"src/{fichier}", f"{docs_folder}/{version}/{my_file}")
                if generate == True and os.path.getsize(f"src/{fichier}") != 0:
                    print(f"[ca65tomd] Generating doc for src/{fichier} to {docs_folder}/{version}/{my_file}")
                    #ca65todoc_c_proto.py
                    if fichier.startswith('_'):
                        resultat = subprocess.run(['python3', generatedoc_cmd_c, f"src/{fichier}", f"{docs_folder}/{version}/{my_file}"], check=True, capture_output=True, text=True)
                    else:
                        resultat = subprocess.run(['python3', generatedoc_cmd_assembly, f"src/{fichier}", f"{docs_folder}/{version}/{my_file}"], check=True, capture_output=True, text=True)


def update_package(args):
    if not os.path.exists(toml_file):
        print("This project is not initialized (Missing bpm.tml)")
        return 1

    folder = "orixlibs"

    if not os.path.exists(folder):
        os.makedirs(folder)

    data = read_local_config_file()
    if "dependencies" in data and len(data["dependencies"]) != 0:
        dependencies = data["dependencies"]
        for key, value in dependencies.items():
            print(f"Updating : {key}")
            remove_dependency_from_toml(key)
            add_dependency_to_toml(toml_file, f"{key}@{value}")


def read_main_config_file():
    # Returns array of the content of main config file
    try:
        # Lire le fichier TOML
        with open(main_config_path, 'r') as file:
            data = toml.load(file)
        return data
    except FileNotFoundError:
        print(f"'{toml_file}' not found")

def execute_binaries(path_oricutron, orix_run_pre_script, oricutron_replace_autoboot_run, binary_to_launch, bin_oricutron, current_pwd, bpm_tmp_folder, names, extra_arg):
    # names : all binaries to name to build

    autoboot_oricutron_folder = "/sdcard/ETC/AUTOBOOT"
    full_autoboot_oricutron_folder = path_oricutron + autoboot_oricutron_folder
    orix_run_pre_script_content = ""

    if orix_run_pre_script != "":
        try:
            # Ouverture et lecture du fichier
            with open(orix_run_pre_script, 'r') as fichier:
                orix_run_pre_script_content = fichier.read()
        except FileNotFoundError:
            print(f"File not found '{orix_run_pre_script}' ('orix_run_pre_script' defines in project config file)")
            exit(1)
        except Exception as e:
            print(f"error : {e}")

    extra_arg_param = ""
    if oricutron_replace_autoboot_run == "True":
        if binary_to_launch == "":
            all_names = ""
            for name in names:
                if extra_arg[name] != "":
                    extra_arg_param = extra_arg[name]

                name_7 = convert_binary_name_to_seven_chars(name)
                all_names = all_names + name_7 + "\n"

            content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{all_names}{extra_arg_param}\n"
        else:
            for myargs in extra_arg:
                extra_arg_param = extra_arg_param + ' ' + extra_arg[myargs]

            name_7 = convert_binary_name_to_seven_chars(binary_to_launch)
            content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{name_7} {extra_arg_param}\n"

        if os.path.exists(full_autoboot_oricutron_folder):
            shutil.copy(full_autoboot_oricutron_folder, bpm_tmp_folder + "AUTOBOOT_OLD")
            old_autoboot_exists = True
        with open(full_autoboot_oricutron_folder, 'w') as file:
            file.write(content)
    os.chdir(path_oricutron)
    try:
        print(f"Execute : {bin_oricutron}")
        subprocess.run([bin_oricutron], check=True)
    except Exception as e:
        print(f"Error : {e}")
    finally:
        # Revenir au répertoire initial
        os.chdir(current_pwd)
        if oricutron_replace_autoboot_run == "True" and old_autoboot_exists:
            print("Restore old autoboot")
            shutil.copy(bpm_tmp_folder + "AUTOBOOT_OLD", full_autoboot_oricutron_folder)


def run_bin(args):
    bpm_tmp_folder = "bpmtmp/"
    old_autoboot_exists = False
    current_pwd = os.getcwd()
    binary_to_launch = ""
    orix_run_pre_script = ""
    extra_args = {}
    pos_extra_arg = 0
    bin_option_found = 0

    if len(sys.argv) > 2:

        if sys.argv[2] == '--':
            pos_extra_arg = 3


        if sys.argv[3] == '--':
            pos_extra_arg = 4


        if pos_extra_arg != 0:
            for i in range(pos_extra_arg, len(sys.argv)):
                if sys.argv[i] == "--bin":
                    bin_option_found = i
                    break

                extra_args[sys.argv[i]] = sys.argv[i]


        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("Run project\n")
                print("Usage : bpm run [-- arg1] [--bin MYBINARY]\n")
                return

            if sys.argv[2] == '--bin':
                print("Missing binary")
                print("Run project\n")
                print("Usage : bpm run [--bin MYBINARY]\n")
                return

        if len(sys.argv) == 4 or bin_option_found != 0:
            if sys.argv[2] == '--bin':
                binary_to_launch = sys.argv[3]
            if bin_option_found != 0:
                if len(sys.argv) <= bin_option_found + 1:
                    print("Missing binary after --bin")
                    return 1
                binary_to_launch = sys.argv[bin_option_found + 1]

    try:
        # Lire le fichier TOML
        with open(main_config_path, 'r') as file:
            data = toml.load(file)

        if "main" in data:
            path_oricutron = data["main"]["oricutron_path"]
            if path_oricutron == "":
                print("oricutron_path is empty, set it with 'bpm config set oricutron_path *Yourpath*'")
                return
            if not os.path.isfile(path_oricutron):
                print(f"Error : in 'oricutron_path' parameter, {path_oricutron} is not a file. Set Oricutron path with 'bpm config set main oricutron_path *Yourpath*'")
                return

            default_rom_oricutron_for_code = 4

            if "default_rom_oricutron_for_code" in data["main"]:
                if data["main"]["default_rom_oricutron_for_code"] != "":
                    default_rom_oricutron_for_code = int(data["main"]["default_rom_oricutron_for_code"])

    except FileNotFoundError:
        print(f"'{main_config_path}' not found")

    data = read_local_config_file()

    oricutron_replace_autoboot_run = "True"
    if "package" in data:
        name =  data["package"]["name"]
        codetype =  data["package"]["codetype"]
        version =  data["package"]["version"]
        if "default_rom_oricutron_for_code" in data["package"]:
            if data["package"]["default_rom_oricutron_for_code"] != "":
                default_rom_oricutron_for_code = int(data["package"]["default_rom_oricutron_for_code"])

        if "orix_run_pre_script" in data["package"]:
            orix_run_pre_script = data["package"]["orix_run_pre_script"]

        if "oricutron_path" in data["package"]:
            if data["package"]["oricutron_path"] != "":
                path_oricutron_project = data["package"]["oricutron_path"]
                if not os.path.isfile(path_oricutron_project):
                    print(f"Error : in 'oricutron_path' parameter, {path_oricutron_project} is not a file. Set Oricutron path with 'bpm config set project oricutron_path *Yourpath*'")
                    return
                path_oricutron = path_oricutron_project
            oricutron_replace_autoboot_run =  data["package"]["oricutron_replace_autoboot_run"]
    else:
        print("Error 'bpm.tml' does not contains 'package' section")
        return 1

    bin_oricutron = path_oricutron
    path_oricutron = os.path.dirname(path_oricutron)


    #shutil.copy("build/bin/" + name, path_oricutron + "/sdcard/BIN/" + name.upper())
    if os.path.exists(f"{build_folder}/bin"):
        build_bin = f"{build_folder}/bin/"
        dest_oricutron_bin = path_oricutron + "/sdcard/BIN/"
        # Copier tout le contenu de {build_folder}/bin
        for item in os.listdir(build_bin):
            source_path = os.path.join(build_bin, item)
            destination_path = os.path.join(dest_oricutron_bin, item.lower())

            if os.path.isdir(source_path):
                shutil.copytree(source_path, destination_path, dirs_exist_ok=True)
            else:
                shutil.copy2(source_path, destination_path)
                print("Copy ...")

    if codetype == "rom":
        path_to_oricutron_rom = f"sdcard/USR/SHARE/" + name.upper() + "/" + version.upper() + "/"

        if not os.path.exists(path_oricutron + '/' + path_to_oricutron_rom):
            os.makedirs(path_oricutron + '/' + path_to_oricutron_rom, exist_ok=True)

        shutil.copy(f"{build_folder}/usr/share/{name}/{version}/{name}.rom", path_oricutron + '/' + path_to_oricutron_rom)


        path_twilighte_board_cfg_plugin = path_oricutron + "/plugins/twilighte_board/twilighte.cfg"
        with open(path_twilighte_board_cfg_plugin, "r") as file:
            lines = file.readlines()

        if default_rom_oricutron_for_code == "":
            default_rom_oricutron_for_code = 4

        if default_rom_oricutron_for_code < 10:
            default_rom_oricutron_for_code_str = f"rom0{default_rom_oricutron_for_code}"
        else:
            default_rom_oricutron_for_code_str = f"rom{default_rom_oricutron_for_code}"

        if default_rom_oricutron_for_code < 42 and default_rom_oricutron_for_code > 31:
            default_rom_oricutron_for_code_str = f"ram0{default_rom_oricutron_for_code}"

        if default_rom_oricutron_for_code > 42:
            default_rom_oricutron_for_code_str = f"ram{default_rom_oricutron_for_code}"


        twilbank_found = False
        with open(path_twilighte_board_cfg_plugin, "w") as file:
            for line in lines:
                if f"twilbank{default_rom_oricutron_for_code_str}" in line:
                    #print(f"Writing !!!twilbankrom{default_rom_oricutron_for_code_str}")
                    twilbank_found = True
                    file.write(f"twilbank{default_rom_oricutron_for_code_str}='{path_to_oricutron_rom}/{name}'\n")
                    break
                else:
                    file.write(line)

            if not twilbank_found:
                    file.write(f"twilbank{default_rom_oricutron_for_code_str}='{path_to_oricutron_rom}/{name}'\n")

    # if codetype == "bin":
    #     print(path_oricutron + '/sdcard/bin')
    #     shutil.copy(f"build/bin/{name}", path_oricutron + f'/sdcard/bin/{name}')

    # Generate submit file
    if codetype == "bin":
        names = { f"{name}" }
        extra_args[name] = ""

        execute_binaries(path_oricutron, orix_run_pre_script, oricutron_replace_autoboot_run, binary_to_launch, bin_oricutron, current_pwd, bpm_tmp_folder, names, extra_args)

        # autoboot_oricutron_folder = "/sdcard/ETC/AUTOBOOT"
        # full_autoboot_oricutron_folder = path_oricutron + autoboot_oricutron_folder

        # orix_run_pre_script_content = ""
        # if orix_run_pre_script != "":
        #     try:

        #         # Ouverture et lecture du fichier
        #         with open(orix_run_pre_script, 'r') as fichier:
        #             orix_run_pre_script_content = fichier.read()

        #     except FileNotFoundError:
        #         print(f"File not found '{orix_run_pre_script}' ('orix_run_pre_script' defines in project config file)")
        #         exit(1)
        #     except Exception as e:
        #         print(f"error : {e}")

        # if oricutron_replace_autoboot_run == "True":
        #     if binary_to_launch == "":
        #         name_7 = convert_binary_name_to_seven_chars(name)
        #         content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{name_7}{extra_arg}\n"
        #     else:
        #         name_7 = convert_binary_name_to_seven_chars(binary_to_launch)
        #         content = f"#!/bin/submit\n{orix_run_pre_script_content}\n{name_7}\n"

        #     # if not os.path.exists(path_oricutron + "/sdcard/ETC/"):
        #     #     os.makedirs(path_oricutron + "/sdcard/ETC/", exist_ok=True)
        #     #     open(full_autoboot_oricutron_folder, 'a').close()

        #     if os.path.exists(full_autoboot_oricutron_folder):
        #         shutil.copy(full_autoboot_oricutron_folder, bpm_tmp_folder + "AUTOBOOT_OLD")
        #         old_autoboot_exists = True

        #     with open(full_autoboot_oricutron_folder, 'w') as file:
        #         file.write(content)

        # os.chdir(path_oricutron)
        # try:
        #     print(f"Execute : {bin_oricutron}")
        #     subprocess.run([bin_oricutron], check=True)

        # except Exception as e:
        #     print(f"Error : {e}")

        # finally:
        #     # Revenir au répertoire initial
        #     os.chdir(current_pwd)
        #     if oricutron_replace_autoboot_run == "True" and old_autoboot_exists:
        #         print("Restore old autoboot")
        #         shutil.copy(bpm_tmp_folder + "AUTOBOOT_OLD", full_autoboot_oricutron_folder)

    if codetype == 'lib':
    # Afficher tous les noms dans [[bin]]
        if "bin" in data:
            if not os.path.exists(f"{build_folder}/bin/"):
                os.makedirs(f"{build_folder}/bin/", mode=0o755, exist_ok=True)
            names = {}
            extra_args = {}
            for bin_entry in data["bin"]:
                if "name" in bin_entry:
                    binname = bin_entry["name"]
                    key = f"path_{binname}"
                    file_to_compile_c = bin_entry[key]
                    names[bin_entry["name"]] = file_to_compile_c
                    key = f"extra_args_{name}"
                    if key in bin_entry:
                        extra_args[binname] = bin_entry[key]
                    else:
                        extra_args[binname] = ""
            execute_binaries(path_oricutron, orix_run_pre_script, oricutron_replace_autoboot_run, binary_to_launch, bin_oricutron, current_pwd, bpm_tmp_folder, names, extra_args)
        else:
            print("lib is not managed yet with 'bpm run' command")

def dynamic_lib(args):

    if len(sys.argv) == 2:
        print("add        add dynamic lib, lib requires to be in dependencies")
        print("remove     Remove dynamic lib, (revert into static lib)")

    if (len(sys.argv) == 3 and args[2] == 'add') or (len(sys.argv) == 3 and args[2] == 'remove'):
        print("missing arg for add or remove")

    if (len(sys.argv) == 4 and args[2] == 'add') or (len(sys.argv) == 4 and args[2] == 'remove'):
        data = read_local_config_file()

        if "dependencies" in data:
            for chaine in data["dependencies"]:
                if args[3] in chaine:
                    print("Found")
                    if args[3] not in data["dynamiclibs"]:
                        data["dynamiclibs"][args[3]] = ""
                        with open("bpm.tml", 'w') as file:
                            toml.dump(data, file)
                    else:
                        print(f"{args[3]} already in dynamiclibs")
                    return 0
            print(f"Error : dependency '{args[3]}' not found in dependencies")
        else:
            print("'dependencies' section not found in bpm.tml")

def verify_tml():

    conf = read_local_config_file()
    if not "documentation" in conf["package"]:
        modify_local_toml_key('bpm.tml', '', 'package', 'documentation')

    if not "orix_minimal_kernel_version" in conf["package"]:
        modify_local_toml_key('bpm.tml', '', 'package', 'orix_minimal_kernel_version')

    if not "enable_publish" in conf["package"]:
        modify_local_toml_key('bpm.tml', 'True', 'package', 'enable_publish')

    if not "enable_build" in conf["package"]:
        modify_local_toml_key('bpm.tml', 'True', 'package', 'enable_build')

    return conf

def main():

    enable_build = True
    verify_installed()

    if len(sys.argv) == 1:
        check_update_bpm(False)
        plugins_detect("not_display")
        usage()
        sys.exit(1)


    valid_commands = ['build', 'config', 'd', 'doc', 'dynamiclib', 'plugins', 'list', 'add', 'addsrc', 'run', 'remove', 'new', 'install', '-V', 'search', '--force-update', '--disable-check-update', 'package', 'publish', '--replace-for-new-project', 'run', 'update','unpublish']

    if sys.argv[1] not in valid_commands:
        usage()
        sys.exit(1)

    conf = verify_tml()

    if "enable_publish" in conf["package"]:
        enable_publish = conf["package"]["enable_publish"]


    if "enable_build" in conf["package"]:
        enable_build = conf["package"]["enable_build"]


    action = sys.argv[1]

    if action == '--force-update':
        sys.argv.remove("--force-update")
        if len(sys.argv) != 1:
            action = sys.argv[1]
        check_update_bpm(True)
        update_and_force_new_version_for_next_project = 0
        for arg in sys.argv:
            if arg == "--replace-for-new-project":
                update_and_force_new_version_for_next_project = 1
        #update_and_force_new_version_for_next_project
        #--replace-for-new-project
        if update_and_force_new_version_for_next_project == 1:
            plugins_detect("update_and_force_new_version_for_next_project")
        else:
            plugins_detect("not_display")

    elif action == '--disable-check-update':
        sys.argv.remove("--disable-check-update")
        action = sys.argv[1]
    else:
        check_update_bpm(False)
        action = sys.argv[1]
        plugins_detect("not_display")

    if action == 'run':
        if enable_build == 'False':
            print("Build is disabled for this project (enable_build = False)")
        else:
            ret = build(sys.argv)

        if ret == 0:
            run_bin(sys.argv)
        else:
            print("Error during build, cannot run")
            return 1
    elif action == '-V':
        print(VERSION_BPM)
    elif action == 'doc' or action == 'd':
        build_doc(toml_file)
    elif action == 'list':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        read_dependencies_from_toml()
    elif action == 'add':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        if  len(sys.argv) == 3:
            dependency_str = sys.argv[2]
            add_dependency_to_toml(toml_file, dependency_str)
        else:
            print("Missing parameter")
            print("Type 'bpm add --help'")
    elif action == 'dynamiclib':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        dynamic_lib(sys.argv)
    elif action == 'remove':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        if len(sys.argv) == 3:
            dependency_name = sys.argv[2]
            remove_dependency_from_toml(dependency_name)
        else:
            print("remove needs an argument")
    elif action == 'install':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        install_dependency_from_toml(sys.argv)
    elif action == 'addsrc':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        addsrc(sys.argv)

    elif action == 'search':
        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("Search lib\n")
                print("Usage : bpm search [libname]\n")
                return
        to_find = ""
        if len(sys.argv) == 3:
            to_find = sys.argv[2]
        search_lib(to_find)

    elif action == 'update':
        update_package(sys.argv)

    elif action == 'package':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        data = read_local_config_file()
        build_doc(toml_file)
        if enable_build == 'False':
            print("Build is disabled for this project (enable_build = False)")
        else:
            build(sys.argv)
        if data["package"]["codetype"] == "lib":
            package_name = data["package"]["name"] + "lib.tgz"
        else:
            package_name = data["package"]["name"] + ".tgz"
        build_package("build", package_name , data["package"]["name"], data["package"]["version"])
    elif action == 'new':
        init_toml(sys.argv)
    elif action == 'plugins':
        plugins(sys.argv)
    elif action == 'config':
        manage_config(sys.argv)
    elif action == 'build':
        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("bpm build")
                return 0
        if enable_build == 'False':
            print("Build is disabled for this project (enable_build = False)")
        else:
            build(sys.argv)
    elif action == 'init':
        if not os.path.exists(toml_file):
            init_toml(sys.argv)
        else:
            print("Already initialized")
    elif action == 'publish':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        if enable_publish == 'False':
            print("publish is disabled for this project (enable_publish = False)")

        tgz_to_upload = ""
        if len(sys.argv) == 4:
            if sys.argv[2] == 'pathtgz':
                tgz_to_upload = sys.argv[3]

        data = read_local_config_file()

        if tgz_to_upload == "":
            build_doc(toml_file)
            if enable_build == 'False':
                print("Build is disabled for this project (enable_build = False)")
            else:
               build(sys.argv)


        package_name = data["package"]["name"] + ".tgz"

        if tgz_to_upload == "":
            build_package("build", package_name, data["package"]["name"], data["package"]["version"])

        return publish(package_name, sys.argv, "publish")
    elif action == 'unpublish':
        if not os.path.exists(toml_file):
            print("This project is not initialized (Missing bpm.tml)")
            return 1
        data = read_local_config_file()
        if data["package"]["codetype"] == "lib":
            package_name = data["package"]["name"] + "lib.tgz"
        else:
            package_name = data["package"]["name"] + ".tgz"
        return publish(package_name, sys.argv, "unpublish")
    # Lire et afficher les dépendances


if __name__ == "__main__":
    main()
