#!/usr/bin/env python3

import tarfile
import toml
import sys
import requests
import os
import gzip
import tarfile
import shutil
from datetime import datetime
import subprocess
import zipfile
from io import BytesIO
import shutil

VERSION_BPM = "2024.4.20"

main_config_path = os.path.expanduser("~/.bpm/bpm")
folder_path_md2hlp = os.path.expanduser("~/.bpm/md2hlp/")
symbs = [u'\u255a', u'\u2554', u'\u2569', u'\u2566', u'\u2560', u'\u2550', u'\u256c', u'\u2557', u'\u2551', u'\u255a', u'\u255d']

plugins_description = {
    'md2hlp': 'Build markdown into hlp file (text mode)',
    'orixsdk': 'Useful ca65 macro for Orix and reloc binary (Mandatory for Orix projects)',
    'asm_bin_tpl': 'Assembly binary template for Orix'
    }

plugins_installed = {
    'md2hlp': False,
    'orixsdk': False,
    'asm_bin_tpl': False
    }

toml_file = "bpm.tml"
user_folder = '.bpm/'

def decompress_and_extract(filename, dependency_name):
    """Décompresse un fichier .gz et extrait une archive .tar"""
    try:
        # Décompression du fichier .gz
        with gzip.open(filename, 'rb') as f_in:
            with open(filename[:-4] + ".tar", 'wb') as f_out:  # Enlève '.tgz'
                f_out.writelines(f_in)
        os.remove(filename)
        os.makedirs('orixlibs/' + dependency_name, exist_ok=True)
        # Extraction du fichier .tar
        with tarfile.open(filename[:-4] + ".tar", 'r') as tar:
            tar.extractall(path='orixlibs/'+ dependency_name)  # Extrait dans le répertoire orixlibs
        os.remove(filename[:-4] + ".tar")

    except Exception as e:
        print(f"Decrunching error : {e}")

def read_local_config_file():
    file_path = "bpm.tml"
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)
        return data

    except FileNotFoundError:
        print(f"'{file_path}' not found")
    except toml.TomlDecodeError:
        print(f"Impossible to read '{file_path}'.")

def add_dependency_to_toml(file_path, dependency_str):
    """Ajoute une nouvelle dépendance dans la section 'dependency' du fichier TOML"""
    if dependency_str == "--help":
        print("bpm add package@version")
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Si la section "dependency" n'existe pas, la créer
        if "dependencies" not in data:
            data["dependencies"] = {}

        # Séparer le nom de la dépendance et la version
        try:
            dependency_name, dependency_version = dependency_str.split("@")
            dependency_name = dependency_name.strip()
            dependency_version = dependency_version.strip().strip('"').strip("'")
        except ValueError:
            print("Format error : parameter must be : 'nom@\"version\"'.")
            return

        # Ajouter ou mettre à jour la dépendance dans le fichier TOML
        data["dependencies"][dependency_name] = dependency_version

        value = download_file("http://repo.orix.oric.org/dists/" + dependency_version + "/tgz/6502/" + dependency_name + ".tgz", "orixlibs/" + dependency_name + ".tgz", dependency_name)

        if value == 0:
            # Écrire les modifications dans le fichier TOML
            with open(file_path, 'w') as file:
                toml.dump(data, file)

            print(f"{dependency_name} = {dependency_version} installed")
        else:
            print(f"{dependency_name} = {dependency_version} not found")

    except FileNotFoundError:
        print(f"'{file_path}' nnot found")
    except toml.TomlDecodeError:
        print(f"Impossible to read '{file_path}'.")

def download_file(url, local_filename, dependency_name):
    """Télécharge un fichier depuis une URL"""
    os.makedirs('orixlibs', exist_ok=True)
    try:
        response = requests.get(url)
        response.raise_for_status()  # Vérifie si la requête a réussi

        with open(local_filename, 'wb') as f:
            f.write(response.content)

        decompress_and_extract(local_filename, dependency_name)
        return 0
    except requests.exceptions.RequestException as e:
        return 1

def install_dependency_from_toml(args):
    if len(args) == 3:
        if args[2] == "-h":
            print("Install all dependencies\n")
            print("Usage : bpm install\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36minstall\033[0m             install all dependencies for this project")

            return 0

    try:
    # Lire le fichier TOML
        with open(toml_file, 'r') as file:
            data = toml.load(file)

        if "dependencies" in data:
            dependencies = data["dependencies"]
            if len(data["dependencies"]) == 0:
                print("No dependencies")
                return 0
            if len(dependencies) != 0:
                print("Dependencies:")
                for key, value in dependencies.items():
                    value_download = download_file("http://repo.orix.oric.org/dists/" + value + "/tgz/6502/" + key + ".tgz", "orixlibs/" + key + ".tgz", key)
                    if value_download == 0:
                        print(f"{key} = {value} installed")
                    else:
                        print(f"{key} = {value} not found")

    except FileNotFoundError:
        print(f"'{toml_file}' not found")

def read_dependencies_from_toml(file_path):
    try:
        # Lire le fichier TOML
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Vérifier si la section "dependency" existe
        if "dependencies" in data:
            dependencies = data["dependencies"]
            if len(dependencies) != 0:
                print("Dependencies list :")
            else:
                print("No dependencies")
            for key, value in dependencies.items():
                print(f"{key} = {value}")
        else:
            print("'dependencies' section does not exists in bpm.tml")
    except FileNotFoundError:
        print(f"file not found : '{file_path}'")
    except toml.TomlDecodeError:
        print(f"Read error :  '{file_path}'.")

def remove_dependency_from_toml(file_path, dependency_name):
    """Supprime une dépendance de la section 'dependency' du fichier TOML"""
    try:
        with open(file_path, 'r') as file:
            data = toml.load(file)

        # Vérifier si la section "dependency" existe
        if "dependencies" in data and dependency_name in data["dependencies"]:
            del data["dependencies"][dependency_name]
            print(f"{dependency_name} uninstalled")
            shutil.rmtree("orixlibs/" + dependency_name)
        else:
            print(f"'{dependency_name}' dependency does not exist in bpm.tml")

        # Écrire les modifications dans le fichier TOML
        with open(file_path, 'w') as file:
            toml.dump(data, file)

    except FileNotFoundError:
        print(f"'{file_path}' not found")
    except toml.TomlDecodeError:
        print(f"Impossible to read '{file_path}'.")

def init_toml(args):
    if len(args) == 3:
        if args[2] == '-h':
            print("Init project\n")
            print("Usage : bpm init\n")
            return
            #print("\033[1;32mCommands:\033[0m")
            #print("    \033[1;36minstall\033[0m             install plugin")

    if os.path.exists(toml_file):
        print("Already initialized")
        return 0

    current_directory = os.getcwd()
    last_directory = os.path.basename(os.path.normpath(current_directory))
    now = datetime.now()

    # Récupérer l'année courante
    current_year = now.year

    # Déterminer le trimestre actuel
    current_month = now.month
    current_trimester = (current_month - 1) // 3 + 1

    if not os.path.exists(".gitignore"):
        print("Init .gitignore")
        content = "bpmtmp/\nbuild\n"
        with open(".gitignore", 'w') as file:
            file.write( content)

    #oricutron_replace_autoboot_run

    main_config_data = read_main_config_file()

    oricutron_replace_autoboot_run_for_project = ""
    if "main" in main_config_data:
        main_properties = main_config_data["main"]
        for key, value in main_properties.items():
            if key == "oricutron_replace_autoboot_run":
                oricutron_replace_autoboot_run_for_project = "oricutron_replace_autoboot_run = \"" + value + "\"\n"
                break

    if not os.path.exists("bpm.tml"):
        print("Init bpm.tml")
        """Crée un fichier TOML avec des valeurs par défaut."""
        content = "[package]\nname = \"" + last_directory  + "\"\nversion = \"" + str(current_year) + "." + str(current_trimester) + "\"\nauthors = [ \"nobody@nobody.fr\" ]\nlicense = \"MIT OR Apache-2.0\"\nedition = \"2018\"\ncpu = \"6502\"\n"
        content = content + "readme = \"\"\nrepository = \"\"\ndocumentation = \"\"\ndescription = \"\"\nhomepage = \"\"\nbuildfolder = \"build\"\npackagetype = \"tgz\"\ncodetype = \"bin\"\n"
        content = content + oricutron_replace_autoboot_run_for_project
        content = content + "\n[dependencies]\n"
        with open("bpm.tml", 'w') as file:
            file.write(content)

    if not os.path.exists("src"):
        print("Init src folder")
        os.makedirs("src", mode=0o755, exist_ok=True)

    if not os.path.exists("src/" + last_directory + ".c"):
        print("Init " + "src/" + last_directory + ".c")
        content = "#include <stdio.h>\n main() {printf(\"Hello word\"); }\n"
        with open("src/" + last_directory + ".c", 'w') as file:
            file.write(content)

    if not os.path.exists("VERSION"):
        print("Init VERSION file")
        content = str(current_year) + "." + str(current_trimester)
        with open("VERSION", 'w') as file:
            file.write(content)
    print(f"initialized")

def check_update_bpm(auto_update: bool):
    # Function which test if bpm can be updated
    answer = ""
    today = datetime.today()

    # # Formater la date au format YYYY-MM-DD
    today_format = today.strftime("%Y-%m-%d")

    main_config_data = read_main_config_file()

    if "main" in main_config_data:
        main_properties = main_config_data["main"]
        main_properties.setdefault("last_check_update", "0000-00-00")
        main_properties.setdefault("bpm_version", VERSION_BPM)

    if today_format == main_properties["last_check_update"]:
        return 0

    print("Checking if an update is available (Last check : " + main_config_data["main"]["last_check_update"] + ") ...\n")
    get_version_bpm = "https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/VERSION"
    try:
        response = requests.get(get_version_bpm)
        response.raise_for_status()  # Vérifie si la requête a réussi
        online_version = response.content.decode('utf-8')

        if online_version.replace("\n", "") != main_config_data["main"]["bpm_version"]:
            current_version = main_config_data["main"]["bpm_version"]
            if auto_update == False:
                answer = input(f"A new version of bpm is available.\nCurrent version : {current_version}, Available version : \033[1;36m{online_version}\033[0m .\n if you want to install it, type 'update' or else type 'skip' : \n[update/skip] ? ")

    except requests.exceptions.RequestException as e:
        print("Can not check if a new version of 'bpm' is not available")
        return 1
    main_properties["last_check_update"] = today_format

    if answer == "update" or auto_update == True:
        get_src_bpm = "https://raw.githubusercontent.com/orix-software/bpm/refs/heads/main/src/bpm"
        try:
            response = requests.get(get_src_bpm)
            src_code = response.content.decode('utf-8')
            current_bpm_path = os.path.abspath(__file__)
            print("Write " + current_bpm_path)
            try:
                with open(current_bpm_path, 'w') as fichier:
                    fichier.write(src_code)
                main_properties["bpm_version"] = online_version
                main_properties["last_check_update"] = today_format
            # Afficher toutes les exceptions qui se produisent
            except Exception as e:
                print(f"Une erreur est survenue lors de l'écriture : {e}")

        except requests.exceptions.RequestException as e:
            print("Can not update")
            return 1

    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    try:
        # Update file
        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write( "[main]\n")
            for key, value in main_properties.items():
                fichier.write(f"{key} = \"{value}\"\n")
    except FileNotFoundError:
        print(f"'{main_config_path}' not found")

def verify_installed():
    home_directory = os.path.expanduser('~')
    directory_path = home_directory + "/" + user_folder
    if not os.path.exists(directory_path):
        # Créer le répertoire
        os.makedirs(directory_path, mode=0o755, exist_ok=True)
    if not os.path.isfile(directory_path + "/bpm"):
        # Créer le répertoire
        str_init = "[main]\noricutron_path = \"oricutron\"\noricutron_replace_autoboot_run = \"True\"\n"
        str_init = str_init + "bpm_version = \"" + VERSION_BPM + "\"\n"
        str_init = str_init + "last_check_update = \"0000-00-00\"\n"
        with open(directory_path + "/bpm", 'w') as fichier:
            fichier.write(str_init)  # Crée un fichier vide

def search_lib(search_word: str):

    """Télécharge un fichier depuis une URL"""

    try:
        response = requests.get("http://repo.orix.oric.org/dists/official/tgz/6502/listtgz.txt")
        response.raise_for_status()  # Vérifie si la requête a réussi
        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/6502/"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory

        # Vérifier si le répertoire existe déjà
        if not os.path.exists(directory_path):
            # Créer le répertoire
            os.makedirs(directory_path, mode=0o755, exist_ok=True)

        content = ""
        for line in response.iter_lines():
            if line:  # Pour éviter les lignes vides
                content = content + line.decode('utf-8') + '\n'

        with open(directory_path + "/listtgz.txt", 'wb') as f:
            f.write(response.content)
        if search_word == "":
            content = content.replace(';lib', '')  # Retirer ";lib"
            content = content.replace(';', ' ')    # Remplacer ; par des espaces
            print(content)
        else:
            with open(directory_path + "/listtgz.txt", 'r') as file:
                for line_number, line in enumerate(file, start=1):
                    # Si le mot clé est trouvé dans la ligne
                    line_split = line.split(';')
                    if line_split[2].strip() == 'lib':
                        if search_word in line_split[0]:
                            print(line_split[0] + ' ' +line_split[1])

        return 0
    except requests.exceptions.RequestException as e:
        return 1

def build_package(source_dir, output_filename, name, version):
    if not os.path.exists(f"build/etc/bpm/{name}/{version}"):
        # Créer le répertoire
        os.makedirs(f"build/etc/bpm/{name}/{version}", mode=0o755, exist_ok=True)
    if os.path.exists("README.md"):
        shutil.copy("README.md", f"build/etc/bpm/{name}/{version}/README.md")
    shutil.copy("bpm.tml", f"build/etc/bpm/{name}/{version}/bpm.tpl")
    with tarfile.open(output_filename, "w:gz") as tar:
        tar.add(source_dir, arcname=os.path.basename(source_dir))


def lister_fichiers_s(repertoire):
    fichiers_s = [fichier for fichier in os.listdir(repertoire) if fichier.endswith('.s')]
    return fichiers_s


def generate_lib_for_bin(name: str):

    for fichier in os.listdir("src/"):
        assembly = False
        # Vérifier si le fichier a l'extension .md
        if fichier.endswith(".s") or fichier.endswith(".c") or fichier.endswith(".asm"):
            if  os.path.exists("src/" + name + ".s"):
                assembly = True
                fichier_o = fichier.replace(".s", ".o")
            else:
                fichier_o = fichier.replace(".c", ".o")

            if assembly == True and fichier != name + ".s":
                resultat = subprocess.run(['ca65', '-ttelestrat', "src/" + fichier, "-o", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
                resultat = subprocess.run(['ar65', 'r', name + ".lib", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)

            if assembly == False and fichier != name + ".c":
                resultat = subprocess.run(['cc65', '-ttelestrat', "src/" + fichier, "-o", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)
                resultat = subprocess.run(['ar65', 'r', name + ".lib", "bpmtmp/" + fichier_o] , check=True, capture_output=False, text=True)


def build(args):
    repertoire = 'src/'
    fichiers_s = lister_fichiers_s(repertoire)
    bpm_tmp_folder = "bpmtmp/"

    if shutil.which("cl65") is None:
        print("Error: cl65 is not installed")
        return 1

    if shutil.which("ar65") is None:
        print("Error: ar65 is not installed")
        return 1


    if not os.path.exists(bpm_tmp_folder):
        # Créer le répertoire
        os.makedirs(bpm_tmp_folder, mode=0o755, exist_ok=True)

    if not os.path.exists("build"):
        os.makedirs("build", mode=0o755, exist_ok=True)

    with open(toml_file, 'r') as file:
        data = toml.load(file)

    codetype = ""
    if "package" in data:
        package = data["package"]
        codetype = data["package"]["codetype"]
        name = data["package"]["name"]
        version = data["package"]["version"]

    if not os.path.exists(f"build/etc/bpm/{version}"):
        #build/etc/bpm/file/2024.4/
        print(f"Creating build/etc/bpm/{name}/{version}")
        os.makedirs(f"build/etc/bpm/{name}/{version}", mode=0o755, exist_ok=True)

    shutil.copy("bpm.tml", f"build/etc/bpm/{name}/{version}/bpm.tml")

    if codetype == "bin":
        if not os.path.exists("build/bin/"):
            os.makedirs("build/bin/", mode=0o755, exist_ok=True)

        home_directory = os.path.expanduser('~')
        new_directory = f"{user_folder}/orixsdk/orix-sdk-master/bin/relocbin.py3"

        reloc_bin_path = home_directory + "/" + new_directory

        if not os.path.exists(reloc_bin_path):
            print("Error. Can not build without Orix sdk. Orix sdk not installed. orix sdk plugins is required to build binaries (see 'bpm plugins')")
            return 1

        generate_lib_for_bin(name)

        nom_sans_extension = name
        file_to_compile_c = repertoire + name + ".c"
        if os.path.exists(file_to_compile_c):
            try:
                resultat = subprocess.run(['cl65', '-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + '2048', '--start-addr',  '2048',  "--include-dir", "src/include"], check=True, capture_output=False, text=True)
                resultat = subprocess.run(['cl65', '-ttelestrat', file_to_compile_c, "-o", bpm_tmp_folder + '2304', '--start-addr',  '2304',  "--include-dir", "src/include"], check=True, capture_output=False, text=True)
                resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + nom_sans_extension, '-2' ,bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                shutil.copy(bpm_tmp_folder + nom_sans_extension, "build/bin/" + nom_sans_extension)
                print("Built : " + "build/bin/" + nom_sans_extension)
            except subprocess.CalledProcessError as e:
                print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")
            return 0

        file_to_compile_s = repertoire + name + ".s"
        if os.path.exists(file_to_compile_s):
            try:
                resultat = subprocess.run(['cl65', '-ttelestrat', file_to_compile_s, "-o", bpm_tmp_folder + '2048', '--start-addr',  '2048',  "--include-dir", "src/include"], check=True, capture_output=False, text=True)
                resultat = subprocess.run(['cl65', '-ttelestrat', file_to_compile_s, "-o", bpm_tmp_folder + '2304', '--start-addr',  '2304',  "--include-dir", "src/include"], check=True, capture_output=False, text=True)
                resultat = subprocess.run(["python3" , reloc_bin_path, "-o", bpm_tmp_folder + nom_sans_extension, '-2' ,bpm_tmp_folder + '2048', bpm_tmp_folder + '2304'], check=True, capture_output=False, text=True)
                shutil.copy(bpm_tmp_folder + nom_sans_extension, "build/bin/" + nom_sans_extension)
                print("Built : " + "build/bin/" + nom_sans_extension)
                return 0
            except subprocess.CalledProcessError as e:
                print(f"Command {e.cmd} returned with error code {e.returncode}. Output: {e.output} Error: {e.stderr}")

        print(f"Main file not found : {file_to_compile_c} or {file_to_compile_s}")


    if codetype == "lib":
        for fichier in fichiers_s:
            nom_sans_extension = os.path.splitext(fichier)[0]
            print("Building " + repertoire + fichier)
            resultat = subprocess.run(['ca65', '-ttelestrat', repertoire + fichier, "-o", bpm_tmp_folder+ nom_sans_extension + ".o", "--include-dir", "src/include"], check=True, capture_output=True, text=True)
            if codetype == "lib":
                print("Adding " + bpm_tmp_folder + nom_sans_extension + ".o to " + name + ".lib")
                resultat = subprocess.run(['ar65', 'r', name + ".lib", bpm_tmp_folder + nom_sans_extension + ".o"], check=True, capture_output=True, text=True)


def usage():
    print("Orix build and package manager\n")
    print("Usage : bpm [OPTIONS] [COMMAND]\n")
    print("\033[1;32mOptions:\033[0m")
    print("    \033[1;36m-V\033[0m              Displays version")
    print("    \033[1;36m--disable-check-update\033[0m              Disables check for new version")
    print("    \033[1;36m--force-update\033[0m              Force bpm update")

    print("")
    print("\033[1;32mCommands:\033[0m")
    print("    \033[1;36mnew\033[0m             Init a new orix package")
    print("    \033[1;36minit\033[0m            Init an orix package in an existing directory")
    print("    \033[1;36mbuild\033[0m           Build")
    print("    \033[1;36mdoc\033[0m             Build docs")
    print("    \033[1;36mrun\033[0m             Run")
    print("    \033[1;36mlist\033[0m            List packages")
    print("    \033[1;36madd         \033[0m    Add dependencies to a manifest file")
    print("    \033[1;36mremove      \033[0m    Remove dependencies from a manifest file")
    print("    \033[1;36minstall     \033[0m    Install all dependencies from a manifest file")
    print("    \033[1;36msearch      \033[0m    Search package")
    print("    \033[1;36mpublish     \033[0m    Publish package")
    print("    \033[1;36munpublish   \033[0m    Unpublish package")
    print("    \033[1;36mplugins     \033[0m    Manage plugins")
    print("    \033[1;36mconfig      \033[0m    Manage config")
    print("    \033[1;36mpackage     \033[0m    Manage package")

def plugins_detect(mode):
    for cle, valeur in plugins_description.items():
        if mode == "display":
            print(f"\033[1;36m{cle}\033[0m: {valeur}", end="")

        if cle == "md2hlp":
            file_path = os.path.join(folder_path_md2hlp , "md2hlp-master/")
            if not os.path.exists(file_path):
                if mode == "display":
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    plugins_installed['md2hlp'] = False
            else:
                if mode == "display":
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['md2hlp'] = True

        if cle == "orixsdk":
            folder_path_orixsdk = os.path.expanduser("~/.bpm/orixsdk/")
            file_path = os.path.join(folder_path_orixsdk , "")
            if not os.path.exists(file_path):
                if mode == "display":
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    plugins_installed['md2hlp'] = False
            else:
                if mode == "display":
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['md2hlp'] = True

        if cle == "asm_bin_tpl":
            folder_path_asm_bin = os.path.expanduser("~/.bpm/tpl/asm_bin_tpl/")
            file_path = os.path.join(folder_path_asm_bin , "")
            if not os.path.exists(file_path):
                if mode == "display":
                    print(" \033[1;31m[Uninstalled]\033[0m")
                else:
                    plugins_installed['md2hlp'] = False
            else:
                if mode == "display":
                    print(" \033[1;32m[Installed]\033[0m")
                else:
                    plugins_installed['md2hlp'] = True

def plugins(args):
    if len(args) == 3:
        if args[2] == "-h":
            print("Manage plugins\n")
            print("Usage : bpm plugins [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36minstall\033[0m             install plugin")
            return 0

    if len(args) == 4:
        if args[3] == "-h":
            print("Manage plugins\n")
            print("Usage : bpm plugins install [plugin_name]\n")
            print("\033[1;32mAvailables plugins:\033[0m")

            for cle, valeur in plugins_description.items():
                print(f"\033[1;36m{cle}\033[0m: {valeur}")
            return 0

    if len(sys.argv) >= 3:
        if sys.argv[2] == "install":
            if len(sys.argv) == 4:
                if sys.argv[3] == "orixsdk":
                    install_orixsdk()
                elif sys.argv[3] == "asm_bin_tpl":
                    install_asm_bin_tpl()
                elif sys.argv[3] == "md2hlp":
                    install_md2hlp()
                else:
                    print("Unknown plugin")
            else:
                print("Missing parameter")
        else:
            print("Unknown parameter")

    if len(sys.argv) == 2:
        print("Use 'bpm plugins -h' for 'plugins' help")
        plugins_detect("display")


def modify_local_toml_key(toml_file, new_name, section, property):
    # Lire le fichier TOML
    with open(toml_file, 'r') as fichier:
        contenu = toml.load(fichier)

    # Vérifier si la section section existe et changer la valeur de 'name'
    contenu[section][property] = new_name


    # Réécrire le fichier avec la nouvelle valeur
    with open(toml_file, 'w') as fichier:
        toml.dump(contenu, fichier)

    print(f"'{property}' updated with '{new_name}'.")

def print_frame(str_to_display, sep):
    print(symbs[1], end = '')
    str_length = len(str_to_display)
    for i in range( str_length + 2):
        print(symbs[5], end = '')
    print(symbs[7])
    print(symbs[8] + ' ', end = '')
    print(str_to_display + ' ' + symbs[8])
    print(symbs[9], end = '')
    for i in range( str_length + 2):
        print(symbs[5], end = '')
    print(symbs[10])

def manage_config(args):

    valid_parameters_main = ['oricutron_path' , 'oricutron_replace_autoboot_run']
    valid_parameters_main_desc = ['                  Set Oricutron path for main (general behavior), value must be path of Oricutron binary with filename binary in the path',
                                  '  Set False or True. False will not modify /etc/autoboot in Oricutron']

    valid_parameters_main_verify = ['path', 'boolean']

    valid_parameters_project = ['name',  'codetype', 'oricutron_replace_autoboot_run']
    valid_parameters_project_desc = ['                            Name of the project',
                                     '                        Code type of the project (lib is a library, bin a command line [lib|bin]',
                                     '  Set False or True. False will not modify /etc/autoboot in Oricutron when bpm run is executed']
    valid_parameters_project_verify = ['string', 'values=bin,lib' ,'boolean']

    # bpm set main -h
    if len(args) == 5:
        if args[4] == '-h' and args[2] == 'set' and args[3] == 'main':
            # bpm set main -h
            print("Set main config parameters\n")
            print("Usage : bpm config set main parameter value\n")
            print("\033[1;32mParameters\033[0m")
            i = 0
            for key in valid_parameters_main:
                print(f"    \033[1;36m{key}\033[0m{valid_parameters_main_desc[i]}")
                i = i + 1
            return 0

    if len(args) == 5:
        if args[4] == '-h' and args[2] == 'set' and args[3] == 'project':
            print("Manage config\n")
            print("Usage : bpm config set project parameter value\n")
            print("\033[1;32mParameters\033[0m")
            i = 0
            for key in valid_parameters_project:
                print(f"    \033[1;36m{key}\033[0m{valid_parameters_project_desc[i]}")
                i = i + 1
            return 0

    # bpm set -h
    if len(args) == 4:
        if args[3] == '-h' and args[2] == 'set':
            print("Manage config\n")
            print("Usage : bpm config set [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mmain\033[0m             set value for 'main' config (use -h after set for 'main' help)")
            print("    \033[1;36mproject\033[0m          set value for 'project' config (use -h after set for 'project' help)")
            return 0

    if len(args) == 3:
        if args[2] == '-h':
            print("Manage config\n")
            print("Usage : bpm config [command]\n")
            print("\033[1;32mCommands:\033[0m")
            print("    \033[1;36mset\033[0m             set value for main config or project config (use -h after set for 'set' help)")
            return 0

    if len(args) == 5:
        if args[4] not in valid_parameters_project and args[3] == 'project':
            print("'" + args[4] + "' is not a parameter allowed for '" + args[3] + "'")
            return 1

        if args[4] not in valid_parameters_main  and args[3] == 'main':
            print("'" + args[4] + "' is not a parameter allowed for '" + args[3] + "'")
            return 1

        if args[2] == 'set' and args[3] == 'main':
            print("Missing value for parameter '" + args[4] + "'")
            return
        if args[2] == 'set' and args[3] == 'project':
            print("Missing value for parameter '" + args[4] + "'")
            return

    if len(args) == 6:
        if args[2] == 'set' and args[3] == 'main':
            if args[4] in valid_parameters_main:
                verify_position = valid_parameters_main.index(args[4])
                if valid_parameters_main_verify[verify_position] == 'boolean':
                    if args[5] != 'True' and args[5] != 'False':
                        print(f"Error {args[4]} requires True or False")
                        return

                home_directory = os.path.expanduser('~')

                new_directory = f"{user_folder}/bpm"
                # Chemin complet du nouveau répertoire
                directory_path = home_directory + "/" + new_directory

                print("Updating 'main' config value ...")
                modify_local_toml_key(directory_path, args[5], 'main', args[4])
                return
            else:
                print(f"Unknown key '{args[4]}' for 'main' config")
                return

        if args[2] == 'set' and args[3] == 'project':
            verify_position = valid_parameters_project.index(args[4])
            if args[4] in valid_parameters_project:
                if valid_parameters_project_verify[verify_position] == 'boolean':
                    if args[5] != 'True' and args[5] != 'False':
                        print(f"Error {args[4]} requires True or False")
                        return
                print("Updating 'project' config value ...")
                modify_local_toml_key('bpm.tml', args[5], 'package', args[4])
                return
            else:
                print(f"Unknown key '{args[4]}' for 'project' config")
                return

    if len(sys.argv) == 2:
        if not os.path.exists("bpm.tml"):
            print("bpm.tml does not exist. Initialize first")
            return 1

        home_directory = os.path.expanduser('~')

        # Nom du répertoire à créer
        new_directory = f"{user_folder}/bpm"

        # Chemin complet du nouveau répertoire
        directory_path = home_directory + "/" + new_directory
        print_frame("Main config", "")

        try:
            with open(directory_path, 'r') as fichier:
                contenu = fichier.read()
                print(contenu)
        except FileNotFoundError:
            print(f"Le fichier '{chemin_fichier}' n'a pas été trouvé.")
        except Exception as e:
            print(f"Une erreur est survenue : {e}")

    print_frame("Project config", "")
    with open(toml_file, 'r') as file:
        data = toml.load(file)

    if "package" in data:
        package = data["package"]
        for key, value in package.items():
            print(f"{key}={value}")


def publish(filename: str, args, mode):
    repo = "alpha"
    if len(args) == 3:
        if mode == "publish":
            if args[2] == "-h":
                print("Manage publish\n")
                print("Usage : bpm publish [OPTIONS]\n")
                print("\033[1;32mOptions:\033[0m")
                print("    \033[1;36m--alpha\033[0m          Publish in alpha repo (default)")
                print("    \033[1;36m--official\033[0m       Publish in official repo")
                print("    \033[1;36m--personnal\033[0m      Publish in personnal (stored in login associated to the the BPM_PUBLISH_KEY) repo")
                return 0
        elif mode == "unpublish":
            if args[2] == "-h":
                print("Unpublish a pacjage\n")
                print("Usage : bpm unpublish [OPTIONS]\n")
                print("\033[1;32mOptions:\033[0m")
                print("    \033[1;36m--alpha\033[0m          Unpublish from alpha repo (default)")
                print("    \033[1;36m--official\033[0m       Unpublish from official repo")
                print("    \033[1;36m--personnal\033[0m      Unpublish from personnal (stored in login associated to the the BPM_PUBLISH_KEY) repo")
                return 0
        if args[2] == "--alpha":
            repo = "alpha"
        elif args[2] == "--official":
            repo = "offical"
        elif args[2] == "--personnal":
            repo = "personnal"
        else:
            print("Unknown parameter")

    conf = read_local_config_file()
    publish_key = os.getenv('BPM_PUBLISH_KEY')
    name = conf["package"]["name"]
    version = conf["package"]["version"]
    cpu = conf["package"]["cpu"]

    if publish_key is None:
        print("BPM_PUBLISH_KEY is not defined")
        return 1

    if mode == "publish":
        action = "add"

    if mode == "unpublish":
        action = "delete"

    url = f"http://api.orix.oric.org/v1/libtgz?cpu={cpu}&repo={repo}&version={version}&name={name}&action={action}&key=" + publish_key

    if mode == "publish":
        with open(filename, 'rb') as fichier:
            fichiers = {filename: fichier}  # Préparer le fichier pour l'envoi

            # Effectuer la requête POST
            response = requests.post(url, files=fichiers)
            print(response.content)
            # Vérifier si la requête a réussi
            if response.status_code == 200:
                print("Success!")
            else:
                print(f"Failed. Error code : {response.status_code}")
                print(f"API response: {response.text}")

    if mode == "unpublish":
        # Effectuer la requête POST
        response = requests.post(url)
        print(response.content)
        # Vérifier si la requête a réussi
        if response.status_code == 200:
            print("Success!")
        else:
            print(f"Failed. Error code : {response.status_code}")
            print(f"API response: {response.text}")

def install_asm_bin_tpl():
    # Chatgpt:
    # Si le folder ~/.bpm/tpl/asm_bin_tpl/ n'existe pas, telecharge https://github.com/assinie/new-project/archive/refs/heads/main.zip, dezippe le dans ~/.bpm/tpl/
    # Définir le chemin du dossier asm_bin_tpl
    folder_path = os.path.expanduser("~/.bpm/tpl/asm_bin_tpl/")

    # Vérifier si le dossier existe
    if not os.path.exists(folder_path):

        # Créer le dossier parent ~/.bpm/tpl/ s'il n'existe pas
        parent_folder = os.path.dirname(folder_path)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        # Télécharger l'archive depuis GitHub
        url = "https://github.com/assinie/new-project/archive/refs/heads/main.zip"
        response = requests.get(url)

        # Vérifier si le téléchargement est réussi
        if response.status_code == 200:
            # Décompresser l'archive
            with zipfile.ZipFile(BytesIO(response.content)) as z:
                z.extractall(parent_folder)  # Décompresser dans ~/.bpm/tpl/
            print("Installed")

        else:
            print("Erreur lors du téléchargement. Code de statut:", response.status_code)
    else:
        print("Le dossier asm_bin_tpl existe déjà dans", folder_path)


def install_orixsdk():
    # Chatgpt:
    # Si le folder ~/.bpm/orixsdk/ n'existe pas, telecharge https://github.com/assinie/orix-sdk/archive/refs/heads/master.zip, dezippe le dans ~/.bpm/
    folder_path = os.path.expanduser("~/.bpm/orixsdk/")

    # Vérifier si le dossier existe
    if not os.path.exists(folder_path):
        print("Orixsdk folder does not exist. Downloading ...")

        # Créer le dossier parent ~/.bpm/ s'il n'existe pas
        parent_folder = os.path.dirname(folder_path)
        if not os.path.exists(parent_folder):
            os.makedirs(parent_folder)

        # Télécharger l'archive depuis GitHub
        url = "https://github.com/assinie/orix-sdk/archive/refs/heads/master.zip"
        response = requests.get(url)

        # Vérifier si le téléchargement est réussi
        if response.status_code == 200:

            # Décompresser l'archive
            with zipfile.ZipFile(BytesIO(response.content)) as z:
                z.extractall(parent_folder)  # Décompresser dans ~/.bpm/
            print("Orix-sdk Installed")

        else:
            print("Download error. Status code:", response.status_code)
    else:
        print("Orix-sdk Already installed")

def install_md2hlp():
    # Chatgpt:
    # Si le folder ~/.bpm/md2hlp/ n'existe pas, telecharge https://github.com/assinie/md2hlp/archive/refs/heads/master.zip, dezippe le dans ~/.bpm/md2hlp/
    print("Installing md2hlp")

    # Créer le dossier s'il n'existe pas
    if not os.path.exists(folder_path_md2hlp):
        os.makedirs(folder_path_md2hlp )

        # Télécharger l'archive depuis GitHub
    url = "https://github.com/assinie/md2hlp/archive/refs/heads/master.zip"
    response = requests.get(url)

    # Vérifier si le téléchargement est réussi
    if response.status_code == 200:

        # Décompresser l'archive
        with zipfile.ZipFile(BytesIO(response.content)) as z:
            z.extractall(folder_path_md2hlp )

        print("md2hlp installed")
    else:
        print("Download error. Error code :", response.status_code)

def build_doc(toml_file):
    # Test md2hlp
    # Chatgpt :
    plugins_detect("detect")
    if not plugins_installed['md2hlp']:
        install_md2hlp()
    plugins_detect("detect")

    if not plugins_installed['md2hlp']:
        print('md2hlp not detected')
        return 1

    if not os.path.exists("src/md2hlp.cfg"):
        home_directory = os.path.expanduser('~')
        directory_path = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.cfg"
        shutil.copy(directory_path, "docs/")

    if not os.path.exists("build/usr/share/man/"):
        os.makedirs("build/usr/share/man/", exist_ok=True)

    home_directory = os.path.expanduser('~')
    md2hlp_cmd = home_directory + "/.bpm/md2hlp/md2hlp-master/src/md2hlp.py3"

    for fichier in os.listdir("docs"):
        # Vérifier si le fichier a l'extension .md
        if fichier.endswith(".md"):
            my_file = fichier.replace('.md', ".hlp")
            print(f"Generating {fichier} to build/usr/share/man/{my_file}")
            resultat = subprocess.run(['python3', md2hlp_cmd, '--config', 'docs/md2hlp.cfg',  '--file', f"docs/{fichier}", "--output", f"build/usr/share/man/{my_file}"] , check=True, capture_output=False, text=True)


def read_main_config_file():
    # Returns array of the content of main config file
    try:
        # Lire le fichier TOML
        with open(main_config_path, 'r') as file:
            data = toml.load(file)
        return data
    except FileNotFoundError:
        print(f"'{toml_file}' not found")


def run_bin(args):
    bpm_tmp_folder = "bpmtmp/"

    if len(sys.argv) == 3:
        if sys.argv[2] == '-h':
            print("Run project\n")
            print("Usage : bpm run\n")
            return

    try:
        # Lire le fichier TOML
        with open(main_config_path, 'r') as file:
            data = toml.load(file)

        if "main" in data:
            dependencies = data["main"]
            for key, value in dependencies.items():
                if key == "oricutron_path":
                    current_pwd = os.getcwd()
                    if value == "":
                        print("oricutron_path is empty, set it with 'bpm config set oricutron_path *Yourpath*'")
                        return
                    if not os.path.isfile(value):
                        print(f"Error : in 'oricutron_path' parameter, {value} is not a file. Set Oricutron path with 'bpm config set oricutron_path *Yourpath*'")
                        return
                    try:

                        with open("bpm.tml", 'r') as file:
                            data = toml.load(file)

                        oricutron_replace_autoboot_run = "True"
                        if "package" in data:
                            package = data["package"]
                            name_bin =  data["package"]["name"]
                            oricutron_replace_autoboot_run =  data["package"]["oricutron_replace_autoboot_run"]
                        else:
                            print("Error bpm.tml does not contains 'package' property")
                            return 1

                        filename = os.path.basename(value)
                        path_oricutron = os.path.dirname(value)
                        print(" ### Oricutron ### ")
                        print(path_oricutron)
                        print(path_oricutron + "/sdcard/bin/")
                        shutil.copy("build/bin/" + name_bin, path_oricutron + "/sdcard/BIN/" + name_bin.upper())

                        old_autoboot_exists = False
                        # Generate submit file

                        if oricutron_replace_autoboot_run == "True":
                            content = f"#!/bin/submit\n{name_bin}\n"
                            if os.path.exists(path_oricutron + "/sdcard/ETC/AUTOBOOT"):
                                shutil.copy(path_oricutron + "/sdcard/ETC/AUTOBOOT", bpm_tmp_folder + " AUTOBOOT_OLD")
                                old_autoboot_exists = True
                            with open(path_oricutron + "/sdcard/ETC/AUTOBOOT", 'w') as file:
                                file.write(content)
                        os.chdir(path_oricutron)
                        subprocess.run([value], check=True)

                    except Exception as e:
                        print(f"Error : {e}")

                    finally:
                        # Revenir au répertoire initial
                        os.chdir(current_pwd)
                        if oricutron_replace_autoboot_run == "True" and old_autoboot_exists:
                            print("Restore old autoboot")
                            shutil.copy(bpm_tmp_folder + "AUTOBOOT_OLD", path_oricutron + "/sdcard/ETC/AUTOBOOT")

    except FileNotFoundError:
        print(f"'{toml_file}' not found")

def main():
    verify_installed()

    if len(sys.argv) == 1:
        usage()
        sys.exit(1)

    valid_commands = ['build', 'config', 'd', 'doc', 'init', 'plugins', 'list', 'add', 'run', 'remove', 'new', 'install', '-V', 'search', '--force-update', '--disable-check-update', 'package', 'publish', 'run', 'unpublish']

    if sys.argv[1] not in valid_commands:
        usage()
        sys.exit(1)

    action = sys.argv[1]

    if action == '--force-update':
        sys.argv.remove("--force-update")
        if len(sys.argv) !=1:
            action = sys.argv[1]
        check_update_bpm(True)
    elif action == '--disable-check-update':
        sys.argv.remove("--disable-check-update")
        action = sys.argv[1]
    else:
        check_update_bpm(False)
        action = sys.argv[1]

    if action == 'run':
        build(sys.argv)
        run_bin(sys.argv)
    elif action == '-V':
        print(VERSION_BPM)
    elif action == 'doc' or action == 'd':
        build_doc(toml_file)
    elif action == 'list':
        read_dependencies_from_toml(toml_file)
    elif action == 'add':
        if  len(sys.argv) == 3:
            dependency_str = sys.argv[2]
            add_dependency_to_toml(toml_file, dependency_str)
        else:
            print("Missing parameter")
            print("Type 'bpm add --help'")
    elif action == 'remove':
        if len(sys.argv) == 3:
            dependency_name = sys.argv[2]
            remove_dependency_from_toml(toml_file, dependency_name)
        else:
            print("remove needs an argument")
    elif action == 'install':
        install_dependency_from_toml(sys.argv)
    elif action == 'search':
        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("Search lib\n")
                print("Usage : bpm search [libname]\n")
                return
        to_find = ""
        if len(sys.argv) == 3:
            to_find = sys.argv[2]
        search_lib(to_find)
    elif action == 'package':
        data = read_local_config_file()
        build_doc(toml_file)
        build_package("build", data["package"]["name"] + ".tgz", data["package"]["name"], data["package"]["version"])
    elif action == 'new':
        init_toml(sys.argv)
    elif action == 'plugins':
        plugins(sys.argv)
    elif action == 'config':
        manage_config(sys.argv)
    elif action == 'build':
        if len(sys.argv) == 3:
            if sys.argv[2] == '-h':
                print("bpm build")
                return 0
        build(sys.argv)
    elif action == 'init':
        if not os.path.exists(toml_file):
            init_toml(sys.argv)
        else:
            print("Already initialized")
    elif action == 'publish':
        data = read_local_config_file()
        build_doc(toml_file)
        build_package("build", data["package"]["name"] + ".tgz", data["package"]["name"], data["package"]["version"])
        publish(data["package"]["name"] + ".tgz", sys.argv, "publish")
    elif action == 'unpublish':
        data = read_local_config_file()
        publish(data["package"]["name"] + ".tgz", sys.argv, "unpublish")
    # Lire et afficher les dépendances


if __name__ == "__main__":
    main()
